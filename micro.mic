;KL10 E-BOX MICRO DIAGNOSTICS
.TOC	"FIRST RAM LOCATIONS RESERVED"

;********************************************
;HERE ARE 9 NUL MICRO WORDS WHICH RESERVE LOW ADDRESS MICRO
;LOCATIONS AS DONT CARE LOCATIONS.. THE ASSEMBLER WILL
;PUT EMPTY NUL RAM CODE HERE, RESERVING THE LOCATIONS FOR PDP11
;USE,AND PUSHING LEGITIMATE RAM CODE ABOVE HERE
0000:
EMPTY:	J/0000,DISP/DIAG,ADB/FM
0001:
NUL001:	AR/AR
0002:
NUL002:	AR/AR
0003:
TRAP03:	J/TRAP03
0004:
NUL004:	AR/AR
0005:
NUL005:	AR/AR
0006:
NUL006:	AR/AR
0007:
NUL007:	AR/AR
0010:
NUL010:	AR/AR
;END OF NUL RAM CODE
;*********************************************
;*********************************************
;ESTABLISH MICRO-CODE VERSION NUMBER
137:	#/VERS
;*********************************************
.TOC	"EDP1:BASIC DATA PATH MUX SELECT TEST"
;ALL TESTS WHICH NEED TEST DATA FROM THE PDP11 HAVE A MICRO
;FUNCTION CALLED "AR FROM PDP11".. THIS FUNCTION IS REALLY
;A NOP OF AR/AR, AND DATA IS FORCE STUFFED INTO THE AR FROM THE
;ELEVEN VIA A DIAGNOSTIC
	AR FROM PDP11	"AR/AR"

;DATA PATH TEST 1, BASIC DATA PATH MUX SELECT

;ADA "10", AR"010", MQ"CLR" -- EXECUTED FOR SUBTEST 2
MIC1EDP:	ADA/MQ,AD/A,AR/AD,COND/REG CTL,MQ CTL/0S

;BR "LOAD", RESET AR BACK TO ZERO -- EXECUTED FOR SUBTEST 3
	BR/AR,AR/ADX,AD/A,ADA/AR,ADA EN/EN

;ADB "10", ARX"010", RESET BR TO ZERO -- EXECUTED FOR SUBTEST 4
	ADB/BR,AD/B,ARX/AD,BR/AR

;BRX "LOAD", RESET ARX -- EXECUTED FOR SUBTEST 5
	BRX/ARX,ARX/AD

;ADXB "10", ARX "110" -- EXECUTED FOR SUBTEST 6
	ADB/BR,AD/B,ARX/ADX,BRX/ARX

;ADA "01", MQ "AD" -- EXECUTED FOR SUBTEST 7
	ADA/ARX,ADA EN/EN,AD/A,MQ/MQM SEL,ARX/MQ,COND/REG CTL,MQ CTL/AD

;ARX "011" -- EXECUTED FOR SUBTEST 8
	ARX/MQ,COND/REG CTL,MQ CTL/0S,AD/A,ADA/AR,ADA EN/EN,AR/AD*2

;AR "110", ADXA "EN" -- EXECUTED FOR SUBTEST 9
	AD/A,AR/ADX,ADA EN/EN

;AR "101", RESET ARX -- EXECUTED FOR SUBTEST 10
	AD/A,ADA/AR,ADA EN/EN,AR/AD*2,ARX/MQ

;ADA "00" -- EXECUTED FOR SUBTEST 11
	AD/A,ADA EN/EN,ADA/AR,ARX/AD

;MQ "SH", ADA "DIS", ADXA "DIS" -- EXECUTED FOR SUBTEST 12
	AR/AD,ARX/AD,MQ/SH,AD/A,ADA EN/0S

;MQ "MQ" -- EXECUTED FOR SUBTEST 13
;THIS CODE EQUIVILANT TO MQ/MQ
	COND/REG CTL,MQ/MQ SEL,AD/B,ADB/AR*4,ARX/ADX*.25

;SETUP -- EXECUTED FOR SUBTEST 14
;THIS EQUIVILANT TO MQ/MQ
	ARX/MQ,COND/REG CTL,MQ/MQ SEL,AD/A,ADA/ARX,ADA EN/EN

;ARX "101" -- EXECUTED FOR SUBTEST 15
	ARX/ADX*2,COND/ARL IND,CLR/MQ,AD/A,ADA/AR,ADA EN/EN

;ARX "000" -- EXECUTED FOR SUBTEST 16
	AD/B,ADB/BR	;TESTING ARX/ARX, DEFAULT MICRO CODE SELECT

;SETUP -- EXECUTED FOR SUBTEST 17
	AD/A,ADA EN/EN,AR/ADX,BRX/ARX,ARX/MQ

;AR "000" -- EXECUTED FOR SUBTEST 18
	AR/AR,AD/A,ADA EN/0S
;AR "100" -- EXECUTED FOR SUBTEST 19
	AR/SH,ADA EN/0S

;SETUP, LOAD BR, CLEAR AR -- EXECUTED FOR SUBTEST 20
	BR/AR,AR/ADX,ARX/ADX*2

;ADB "01" -- EXECUTED FOR SUBTEST 21
	AD/B,ADB/BR*2,AR/AD,BR/AR

;ADXB "01" ** -- EXECUTED FOR SUBTEST 22
	AD/B,ADB/BR*2,ARX/ADX,AR/AD,BR/AR

;ARX "111" -- EXECUTED FOR SUBTEST 23
	ARX/ADX*.25,AD/A,ADA EN/EN,ADA/MQ

;SETUP -- EXECUTED FOR SUBTEST 24
	ADA EN/0S,AD/A,AR/AD

;AR "111", RESET ARX,BR -- EXECUTED FOR SUBTEST 25
	ARX/MQ,AD/B,ADB/BR,AR/AD*.25,BR/AR

;ARX "100", RESET AR,SET MQ -- EXECUTED FOR SUBTEST 26
	ADA/MQ,AR/AD,MQ/SH,AD/A,ADA EN/EN

;MQ "*.25", RESET ARX -- EXECUTED FOR SUBTEST 27
	ARX/SH,MQ/MQ*.25,SPEC/MQ SHIFT,AD/A,ADA/AR,ADA EN/EN

;MQ "*2" ** -- EXECUTED FOR SUBTEST 28
	DISP/DIV,AD/A,ADA/AR,ADA EN/EN

=11
;MQ "*.5" ** -- EXECUTED FOR SUBTEST 29
	COND/REG CTL,MQ/MQ SEL,MQ CTL/MQ*.5,AD/A,ADA/AR,ADA EN/EN

;MQ "*.25", VIA 2ND PATH ** -- EXECUTED FOR SUBTEST 30
	DISP/MUL,MQ/MQM SEL,AD/B,ADB/BR,ARX/ADX,BRX/ARX,AR/ADX

=11
;ADXB "11" WITH ONES -- EXECUTED FOR SUBTEST 31
	ADB/AR*4,AD/B,AR/EBUS,COND/EBUS CTL,EBUS CTL/DISABLE CS HOLD

;ADXB "01" WITH ZEROES -- EXECUTED FOR SUBTEST 32
	AD/B,ADB/BR*2,COND/REG CTL,MQ CTL/1S,MQ/MQM SEL,AR/AD,ARX/ADX,
	    BRX/ARX
;ADXB "11" WITH ZEROES -- EXECUTED FOR SUBTEST 33
	ADB/AR*4,AD/B,AR/EBUS

;MQ "*.25" WITH ZEROES - AD TO EBUS WITH ONES -- EXECUTED FOR SUBTEST 34
	AD/A,MQ/SH,ADA/MQ,
	    AR/EBUS,COND/EBUS CTL

=11
;"AR MUX ENABLE" -- EXECUTED FOR SUBTEST 35
	COND/AR CLR,ADA/ARX,AD/A,DISP/DIV,BR/AR,TIME/2T

=11
;"DISP/DIV" MQ SH LEFT 2ND TIME -- EXECUTED FOR SUBTEST 36
	DISP/DIV,AD/B,ADB/BR,AR/AD,TIME/2T

=11
;"MQ *.5" --EXECUTED FOR SUBTEST 37
	COND/REG CTL,MQ/MQ SEL,MQ CTL/MQ*.5,AD/A,ADA/AR

;"MQ*.5" 2ND TIME IN A ROW -- EXECUTED FOR SUBTEST 38
	COND/REG CTL,MQ/MQ SEL,MQ CTL/MQ*.5,AD/A,ADA/AR

;"MQ LOADED FROM AD -- EXECUTED FOR SUBTEST 39
	COND/REG CTL,MQ CTL/AD,MQ/MQM SEL

;"MQ*.5" -- SET-UP FOR SUBTEST 41 -- EXECUTED FOR SUBTEST 40
	COND/REG CTL,MQ/MQ SEL,MQ CTL/MQ*.5,AD/A,ADA/AR

;"MQ*.5" PICK UP MQ SHIFT IN LINE S@0 -- EXECUTED FOR SUBTEST 41
	COND/REG CTL,MQ/MQ SEL,MQ CTL/MQ*.5,AD/A,ADA/AR

;MQ LOADED FROM AD -- EXECUTED FOR SUBTEST 42
	COND/REG CTL,MQ/MQM SEL,MQ CTL/AD,AD/A,ADA/AR

;MQ SH LEFT ONCE - SET-UP FOR SUBTEST 43
	DISP/DIV,AD/A,ADA/ARX,TIME/2T

=11
;MQ SH LEFT-MQ SHIFT IN BIT STUCK -- EXECUTED FOR SUBTEST 44
	DISP/DIV,AD/A,ADA/ARX,TIME/2T,J/MIC1EDP
.TOC	"EDP2: DATA PATH BASIC INTERFERENCE- BURST SPEED"
;DATA PATH TEST 2, BASIC INTERFERENCE -- BURST SPEED
;BEGIN BY LOADING INITIAL INTERFERENCE PATTERN TO AR
MIC2EDP:	AR FROM PDP11

;BEGIN BURST HERE - CHECK BR
	BR/AR,AR/ADX,AD/0S
;CHECK ADB TO AD & AD TO ARX INCLUSIVE
	ARX/AD,AD/B,ADB/BR,BR/AR
;CHECK BRX
	BRX/ARX,ARX/AD,AD/0S
;CHECK ADXB TO ADX & ADX TO AR INCLUSIVE
	AR/ADX,AD/B,ADB/BR,BRX/ARX
;CHECK AR TO ADA TO AD & AD TO MQ INCLUSIVE
	AD/A,ADA/AR,COND/REG CTL,MQ/MQM SEL,MQ CTL/AD,AR/ADX,ADA EN/EN
;CHECK MQ TO ARX
	ARX/MQ,MQ/MQ SEL,COND/REG CTL,MQ CTL/0S,AD/A,ADA/AR,ADA EN/EN
;CHECK ARX TO ADXA TO ADX & DONE WITH THIS INTERFERENCE PATTERN
	AR/ADX,AD/A,ARX/AD,ADA/AR,ADA EN/EN,J/MIC2EDP
.TOC	"EDP3: SHIFTER BOARD TEST--BURST SPEED"
;DATA PATH TEST 3, SHIFTER BOARD TEST -- BURST SPEED
;BEGIN BY LOADING THE ARX PATTERN INTO THE BRX &
;THEN THE AR PATTERN INTO THE BR. NEXT LOAD THE
;"SC" COUNT INTO THE AR. NOW BURST. THE DATA WILL
;TRAVEL AT BURST SPEED OVER THE FOLLOWING PATHS. 1) BR
;THRU AD TO AR. 2) BRX THRU ADX TO ARX. 3) SC LOADED
;FROM AR. 4) THEN THE OUTPUT OF THE SHIFTER INTO THE
;MQ,AR, & ARX.
;FIRST LOAD ARX PATTERN TO AR
MIC3EDP: AR FROM PDP11	;PRESETING SC WITH THIS PATTERN
	SPEC/SCM ALT,SC/AR SHIFT	;LOAD PRESET SC COUNT TO SC
	AR FROM PDP11,AD/1S

;LOAD AR PATTERN TO AR THEN TRANSFER ARX PATTERN TO ARX
	ADA/AR,ADA EN/EN,AD/A,ARX/AD
	AR FROM PDP11

;TRANSFER AR & ARX PATTERNS TO BR & BRX RESPECTIVELY,AFTER LOADING SC VALUE
	AD/A,ADA/AR,ADA EN/EN,BR/AR,BRX/ARX,ARX/MQ
	AR FROM PDP11

;BURST BEGINS HERE
	SPEC/SCM ALT,SC/AR SHIFT,AD/B,ADB/BR,AR/AD,ARX/ADX

;SEND SHIFTER OUTPUT TO REGISTERS
	AR/SH,ARX/SH,MQ/SH,AD/A,ADA/AR,ADA EN/EN,J/MIC3EDP
;PHASE TWO OF SHIFTER TEST REQUIRES USE OF DIFFERING
;SHIFT BOARD CONTROL LINES.
MIC3.1SH: COND/REG CTL,MQ/MQM SEL,MQ CTL/1S,
		AD/A,ADA/AR,ADA EN/EN	;SET MQ
	AR FROM PDP11				;ARX TEST PATTERN
	AD/A,ARX/AD,ADA/AR,ADA EN/EN	;AR PATTERN
	AR FROM PDP11
;BURST HERE
	BR/AR,BRX/ARX,	;PATTERNS TO BR & BRX
		ADA/MQ,AD/A,AR/AD,ARX/AD,ADA EN/EN

;ACTUAL TEST OF SH/AR CONTROL LINES
	AD/B,ADB/BR,AR/AD,ARX/ADX,ADA EN/EN

;SHIFTER OUTPUT TO REGISTERS
	SH/AR,AR/SH,MQ/SH,ARX/SH,AD/A,ADA/AR,ADA EN/EN,J/MIC3.2SH
MIC3.2SH: COND/REG CTL,MQ/MQM SEL,MQ CTL/1S,	;SET MQ
		AD/A,ADA/AR,ADA EN/EN
	AR FROM PDP11				;ARX TEST PATTERN
	AD/A,ARX/AD,ADA/AR,ADA EN/EN	;AR PATTERN
	AR FROM PDP11
;BURST HERE
	BR/AR,BRX/ARX,		;PATTERNS TO BR & BRX
		ADA/MQ,AD/A,AR/AD,ARX/AD,ADA EN/EN

;ACTUAL TEST OF SH/ARX CONTROL LINES
	AD/B,ADB/BR,AR/AD,ARX/ADX

;SHIFTER OUTPUT TO REGISTERS
	SH/ARX,AR/SH,ARX/SH,MQ/SH,AD/A,ADA/AR,ADA EN/EN,J/MIC3.3SH
MIC3.3SH: COND/REG CTL,MQ/MQM SEL,MQ CTL/1S,AD/A,ADA/AR,ADA EN/EN ;SET MQ
	AR FROM PDP11		;ARX PATTERN
	AD/A,ARX/AD,ADA/AR,ADA EN/EN	;AR PATTERN
	AR FROM PDP11
;BURST HERE
	BR/AR,BRX/ARX,ADA/MQ,AD/A,AR/AD,ARX/AD	;PATTERNS TO BR & BRX

;ACTUAL TEST OF SH/AR SWAP CONTROL LINES
	AD/B,ADB/BR,AR/AD,ARX/ADX,#/VERS	;***INCLUDE VERSION

;SHIFTER OUTPUT TO REGISTERS
	SH/AR SWAP,AR/SH,MQ/SH,ARX/SH,AD/A,ADA/AR,ADA EN/EN,J/MIC3.3SH


;END OF SHIFTER TEST
.TOC	"EDP4: DATA PATH AD & ADX ALU TEST, INCLUDING CRY SKP NETWORK"
;GROUP ONE - ALU TEST, ARX & BRX USED TO TEST ADX
MIC4EDP: AR FROM PDP11		;BRX PATTERN INTO THE EBOX
	AD/A,ARX/AD		;ARX PATTERN TO EBOX, BRX PATTERN TO ARX
	AR FROM PDP11
	BRX/ARX,AD/0S,ARX/SH,ADB/FM, ;BRX SET, ARX SET
	J/000,	DISP/DRAM J	;AND DISPATCH TO ACTUAL ALU TEST FUNCTION

;GROUP TWO - ALU TEST, AR & BR USED TO TEST AD
MIC4.1AD: AR FROM PDP11		;BR PATTERN TO EBOX
	BR/AR,J/GO		;AR PATTERN TO EBOX

;GROUP THREE - ALU TEST, AR & BR, ARX & BRX, USED TO TEST AD,ADX & CRY SKIP
MIC4.2AD: AR FROM PDP11		;BRX PATTERN INTO THE EBOX
	AD/A,ARX/AD		;ARX PATTERN INTO THE EBOX,BRX TO ARX
	AR FROM PDP11
	AD/A,ARX/AD,BRX/ARX	;BR PATTERN INTO EBOX,BRX SET,ARX SET
	AR FROM PDP11
	BR/AR,J/GO		;BR SET & AR PATTERN SET IN AR.
;STANDARD DEFAULT MACRO FOR ALL ADDER TESTS
	ADDER TEST "ADA/AR,ADA EN/EN,ADB/BR,AR/AD,ARX/ADX,COND/AD FLAGS"

;BEGINNING OF ACTUAL ALU TEST FUNCTIONS AND ALU CHIP SELECTS
=000000
F40:	ADDER TEST,AD/A+1,J/FEND	;ALU FUNCTION 40
F21:	ADDER TEST,AD/ORC,J/NULTIC	;ALU FUNCTION 21
F11:	ADDER TEST,AD/A-B-1,J/FEND	;ALU FUNCTION 11
F51:	ADDER TEST,AD/A-B,J/FEND	;ALU FUNCTION 51
F40GEN:	ADDER TEST,AD/A+1,		;ALU FUNCTION 40 WITH "GEN CRY18"
		SPEC/GEN CRY18,J/FEND
F26:	ADDER TEST,AD/EQV,J/NULTIC	;ALU FUNCTION 26
F0:	ADDER TEST,AD/A+XCRY,J/FEND	;ALU FUNCTION 0
F22:	ADDER TEST,AD/ORCA,J/NULTIC	;ALU FUNCTION 22
F6LONG:	ADDER TEST,AD/A+B,		;ALU FUNCTION 6 WITH "AD LONG"
		J/FEND,SPEC/AD LONG
F46GEN:	ADDER TEST,AD/A+B+1,		;ALU FUNCTION 46 WITH "GEN CRY18"
		SPEC/GEN CRY18,J/FEND
F46LNG:	ADDER TEST,AD/A+B+1,		;ALU FUNCTION 46 WITH "AD LONG"
		SPEC/AD LONG,J/FEND
F6INH:	ADDER TEST,AD/A+B,		;ALU FUNCTION 6 WITH "INH CRY18"
		SPEC/INH CRY18,J/FEND
F6:	ADDER TEST,AD/A+B,J/FEND	;ALU FUNCTION 6
=
NULTIC:	J/FEND		;A NULL MICRO WORD TO SYNC ADDER TEST CLOCK TICS
FEND:	DISP/DIAG,J/0000	;DISPATCH BACK TO CURRENT GROUP
DISPATCHER: J/000, DISP/DRAM J,	;DISPATCH TO ACTUAL ALU TEST FUNCTION
		ADB/FM,ADA EN/0S,AD/0S
GO:	AR FROM PDP11,J/DISPATCHER	;BEGIN TEST SEQUENCE
.TOC	"EDP4A: DATA PATH  '-AD=0' TEST.FLOAT 1S DOWN AD"
;MICRO CODE TO DIRECT AR DATA TO THE AD AND THEN
;SKIP ON "-AD=0"

MIC4A:	AR FROM PDP11		;TEST DATA TO AR
	AD/B,ADA/ARX		;NO AR DATA TO AD
	AD/A,ADA/AR,		;READ AR TO AD
		SKIP/AD#0	;SKIP IF MACHINE WORKS
=0
HALT4A:	J/HALT4A,AD/A,ADA/AR	;MIC-CODE DIDNT SKIP WHEN SHOULD HAVE

	J/MIC4A			;LOOP IF TESTED OK
.TOC	"FAST MEMORY BASIC INTERFERENCE TEST"

MIC5EDP: AD/B,ADB/FM	;LOAD INTERFERENCE PATTERN TO AR
	AR FROM PDP11
;** BURST BEGINS HERE
	BR/AR,AR/ADX		;PATTERN TO BR, ZERO TO AR
	AD/B,ADB/BR,AR/AD	;FULL SPEED-PATTERN BACK TO AR
	COND/FM WRITE,AR/ADX,J/MIC5EDP  ;WRITE TO FM, READY TO TEST RESULTS
.TOC	"FAST MEMORY FULL SPEED ADDRESS AND DATA TEST"
;INITIALIZE EBOX REGISTERS BRX,BR,AR
MIC6EDP: AR FROM PDP11		;770000,,0 ACROSS EBUS
	SH/AR,MQ/SH		;770000,,0 OVER TO MQ & 41,,0 ACROSS EBUS
	AR FROM PDP11
	AD/A,ADA/AR,ARX/AD,ADA EN/EN ;777757,,0 ACROSS EBUS & 41,,0 TO ARX
	AR FROM PDP11
	BRX/ARX,BR/AR,AD/A,ADA/MQ,AR/AD,ADA EN/EN	;LOAD UP BR,AR,BRX

;NOW BRX = 41,,0
;NOW BR  = 777757,,0
;NOW AR & MQ  = 770000,,0

;FILL FM RAM WITH ZEROES
;LOAD CURRENT AC BLOCKS & SET FM ADDRESS IN ARX
FM1:	COND/DIAG FUNC,DIAG FUNC/LD AC BLKS,
	    FMADR/AC0,ADA/AR,ADB/BR,AD/AND,ARX/AD,ADA EN/EN

;GET ZERO TO AR, THEN WRITE FM
	FMADR/AC0,AR/AD,AD/0S
	FMADR/XR,COND/FM WRITE		;ARX 14-17 TO FM ADR
;CHECK THAT FM=0, HALT LOOP IF NO
	ADB/FM,AD/B,SKIP/AD#0,FMADR/XR,AR/AD,J/LBFM
=0
LBFM:	ADB/BR,ADA/AR,ADA EN/EN, ;IF HERE,FM HAS ZERO.INC BLOCK & AC#
		ARX/ADX,AD/A+B,J/LBFM2
HALT00:	J/HALT00,ADB/FM,AD/B,FMADR/XR	;HALT,WRITING 0S TO FM FAILED

;BLOCK AND AC JUST INCREMENTED.WILL GO TO
;FMOK1 WHEN BLOCK AND AC# BACK TO 0
LBFM2:	ADA/ARX,AD/AND,SKIP/AD#0,ADB/BR,ADA EN/EN
=0
FMOK1:	J/FM2

;IF HERE, MUST LOAD 0 TO NEXT FM LOCATION
;MOVE NEXT ADDRESS TO AR AND CONTINUE
	AD/A,AR/ADX,ADA EN/EN,J/FM1
;FAST MEMORY RAM TEST, PHASE II
;THIS SECTION OF MICRO-CODE READS A LOCATION
;VERIFYS 0, WRITES A 1, GOES TO NEXT ADDR, VERIFYS 0
;WRITES A 1 AND SO ON, ONTO THE END OF THE FM RAM
FM2:	AR/AD,AD/A,ADA/MQ,ADA EN/EN	;770000,,0 TO AR

;NOW BRX = 41,,0
;NOW BR  = 777757,,0
;NOW AR & MQ  = 770000,,0

;LOAD CURRENT AC BLOCKS & FM ADDRESS TO ARX
FM3:	COND/DIAG FUNC,DIAG FUNC/LD AC BLKS,
		FMADR/AC0,ADA/AR,ADB/BR,AD/AND,ARX/AD,ADA EN/EN

;GET ONE TO AR,VERIFY FM = 0 THEN WRITE FM 1'S
	FMADR/AC0,AR/AD,AD/1S
	FMADR/XR,ADB/FM,AD/B,SKIP/AD#0,AR/AD,J/LPFM  ;ERR IF FM NON 0
=0
LPFM:	AR/AD,AD/1S,J/LPFM2	;AR GETS DATA TO WRITE TO FM
HALT20:	ADB/FM,AD/B,FMADR/XR,	;HALT IF FM LOCATION WRITTEN BY SOMEONE ELSE
		J/HALT20

;INCREMENT BLOCK AND AC NUMBER,NO JUMP IF = 0
LPFM2:	FMADR/XR,COND/FM WRITE	;ARX 14-17 TO FM ADR & WRITE ONES
	ADB/BR,ADA/AR,AD/A+B,ARX/ADX
	ADA/ARX,AD/AND,SKIP/AD#0,ADB/BR	;TEST BLOCK & FM ADR FOR =0
=0
FMOK3:	J/FM4	;BLOCK & FM ADR = 0. ONTO NEXT PHASE

;MOVE NEXT ADDRESS TO AR AND CONTINUE LOOP
	AD/A,AR/ADX,ADA EN/EN,J/FM3
;FAST MEMORY RAM TEST, PHASE III
;THIS SECTION OF MICRO-CODE STARTS AT THE GREATEST
;FAST MEMORY RAM LOCATION,READS AND VERIFYS A 1, WRITES A 0,
;DECREMENTS TO THE NEXT RAM ADDRESS,VERIFYS 1,WRITES 0
;AND SO ON, ONTO RAM ADDRESS ZERO.
;WHEN COMPLETE, THE FAST MEMORY RAM IS COMPLETLY TESTED
FM4:	AD/A,ADA/MQ,AR/AD,ADA EN/EN	;770000,,0 TO AR

;NOW BRX = 41,,0
;NOW BR  = 777757,,0
;NOW AR & MQ  = 770000,,0

;BEGIN WITH BLOCK & FM ADR = 0
FM5:	AD/SETCA,ADA/AR,AR/AD,ADA EN/EN	;NOW COMPLIMENT BLOCK & FM ADR

;LOAD CURRENT AC BLOCKS
	COND/DIAG FUNC,DIAG FUNC/LD AC BLKS,
		FMADR/AC0,ADA/AR,ADB/BR,AD/AND,ARX/AD,ADA EN/EN

;GET ZERO TO AR,VERIFY FM = 1 THEN WRITE FM 0'S
	FMADR/AC0,AR/AD,AD/0S
	FMADR/XR,ADB/FM,AD/SETCB,SKIP/AD#0,AR/AD,J/LQFM  ;ERR IF FM NON 0
=0
LQFM:	AR/AD,AD/0S,J/LQFM2
HALT40:	J/HALT40,ADB/FM,AD/B,FMADR/XR	;HALTED IF FM NOT 36 ONES

;INCREMENT BLOCK AND AC NUMBER,NO JUMP IF = 0
LQFM2:	FMADR/XR,COND/FM WRITE		;ARX 14-17 TO FM ADR
	AD/SETCA,ARX/ADX,ADA EN/EN
	ADA/ARX,ADB/BR,AD/AND,ARX/AD	;CLR BAD CARRY BIT
	ADB/BR,ADA/AR,ADA EN/EN,AD/A+B,ARX/ADX	;NEXT FM ADDR
	ADA/ARX,AD/AND,SKIP/AD#0,ADB/BR,ADA EN/EN
=0
FMOK5:	J/FMOK5	;8 AC BLOCKS PASS ADDRESSING AND DATA TEST IF END HERE

;IF HERE, MUST LOAD 0 TO NEXT FM LOCATION
;FINALLY MOVE NEXT ADDRESS TO AR AND CONTINUE
	AD/A,ADA EN/EN,AR/ADX,J/FM5
.TOC	"VMA1: VMA & ADDRESS BREAD REGISTER TESTS"
MIC1VMA: AR FROM PDP11	;LOAD INTERFERENCE PATTERN TO AR
	AD/A,ADA/ARX	;INSURE DATA NOT YET AVAILABLE TO VMA OR ADDR BREAK
	COND/DIAG FUNC,DIAG FUNC/DATAO APR,  ;LOAD VMA & ADDRESS BREAK REG.
		AD/A,ADA/AR,VMA/AD,MEM/AD FUNC
.IFNOT/MODEL.B
	AD/A,ADA/ARX,J/MIC1VMA	;REMOVE DATA FROM VMA & ADDR BRK INPUTS
.IF/MODEL.B
	AD/A,ADA/ARX,J/MIC1VMA,	;REMOVE DATA FROM VMA & ADDR BRK INPUTS
	    MEM/LOAD AR		;SET " MCL VMA READ"
.ENDIF/MODEL.B

.TOC	"VMA2: VMA/ADDR BREAK MATCH LOGIC & VMA 18-31=0"
MIC2VMA: AR FROM PDP11,AD/A,ADA/ARX	;LOAD PATTERN TO AR
	AD/A,ADA/AR,VMA/AD,MEM/AD FUNC	;LOAD PATTERN TO VMA
.IFNOT/MODEL.B
	AD/A,ADA/ARX,J/MIC2VMA	;REMOVE DATA FROM VMA & ADDR BRK INPUTS
.IF/MODEL.B
	AD/A,ADA/ARX,J/MIC2VMA,	;REMOVE DATA FROM VMA & ADDR BRK INPUTS
	    MEM/LOAD AR		;SET " MCL VMA READ"
.ENDIF/MODEL.B

.TOC	"EVMA03: PC AND VMA HELD REGISTERS TEST"
;MICRO-CODE TO INITIALIZE THE VMA(13-35),
; PC(13-35), ADR BRK(13-35), AND VMA HELD(13-35)
IMVMA3:	AD/0S,VMA/AD,MEM/AD FUNC  ;ZEROES TO VMA(13-35)
	COND/DIAG FUNC,DIAG FUNC/DATAO APR,
		SPEC/LOAD PC
	COND/LD VMA HELD, J/IMVMA3  ;AND ZEROES TO VMA HELD

;MICRO-CODE FOR LOADING THE VMA WITH TEST PATTERNS, THEN LOADING
;BOTH THE PC AND VMA HELD REGISTERS

MIC3VMA:AR FROM PDP11			;TEST PATTERN TO AR
	VMA/AD,AD/A,ADA/AR,MEM/AD FUNC ;TEST PATTERN VMA
	COND/LD VMA HELD	;TEST PATTERN TO VMA HELD
	ARX/AD,AD/A,ADA/PC	;READ PC CONTENTS THRU ADA
	AR/AD,AD/A,ADA/PC,COND/SEL VMA,  ;READ VMA HELD THRU ADA
	SPEC/LOAD PC,J/MIC3VMA	;AND LOAD PC WITH CURRENT TEST PATTERN

.TOC	"EVMA04-  VMA REGISTER-  VMA INC & VMA DEC TEST"
;THIS MICRO-CODED TEST WILL CHECK THE ABILITY OF THE VMA REGISTER
;BINARY COUNTER TO INCREMENT AND DECREMENT THRU ALL REGISTER BITS

MIC4VMA: AR FROM PDP11		;LOAD AR WITH TEST PATTERN
;BURST BEGINS HERE
	AD/A,ADA/AR,VMA/AD,MEM/AD FUNC	;PATTERN TO VMA 13-35
	COND/VMA INC,AD/0S		;SET VMA BIN COUNTER TO +1
	AR/AD,AD/0S,SPEC/LOAD PC,  ;VMA INCREMENTED TO PC, NOW DEC VMA
		COND/VMA DEC
	COND/LD VMA HELD,  ;INCREMENTED VMA TO AR & DECREMENTED VMA TO HELD
		AR/AD,AD/A,ADA/PC
	ARX/AD,AD/A,ADA/PC,COND/SEL VMA,  ;DECREMENTED VMA TO ARX
		J/MIC4VMA	;AND BACK TO BEGINNING OF LOOP

.TOC	"EVMA04: VMA ADDER ALU TEST"

;VMA ADDER ALU TEST. THIS TEST USES THE VMA ADDER ALU TO ADD MAGIC
; NUMBERS FROM THE CRAM NUMBER FIELD TO THE CONTENTS OF THE PC
;AND THEN PASS THE RESULTS TO THE VMA.
M4.1VMA: AR FROM PDP11		;PC VALUE TO THE VMA
;BURST BEGINS HERE
	AD/A,ADA/AR,VMA/AD,MEM/AD FUNC  ;LOAD PC VALUE TO THE VMA

;THE MAGIC NUMBER FIELD AT "MIC4.2VMA" HAS ALREADY BEEN SET UP
	SPEC/LOAD PC,AD/0S,	;PC PATTERN TO PC
	VMA/AD,MEM/AD FUNC	;AND ZEROES TO VMA

;**NUMBER FIELD,COND FIELD,VMA FIELD & MEM FIELD FILLED IN BY PDP11
M4.2VMA:	J/M4.1VMA	;NUM/,COND/,MEM/,VMA/
.TOC	"VMA AC REF LOGIC AND VMA SECTION 0 LOGIC TEST"
;THIS IS THE MICRO-CODE FOR CHECKING THE VMA AC REF LOGIC AND
;THE VMA SECTION 0 LOGIC. THE MICRO-CODE FOR THIS TEST HAS 5
;BASIC TASKS TO PERFORM 1) SET "MCL PAGE UEBR REF", 2) SET
;"MCL VMA READ", 3) SET "MCL VMA WRITE", 4) SET "MCL VMA EXTENDED",
;AND 5) LOAD THE VMA, BITS 13-35, ALL THE APPROPRIATE TIMES.
;SEE THE ELEVEN CODE PORTION OF THE TEST FOR A DESCRIPTION OF
;THE ACTUAL PATTERNS BEING IMPLIMENTED.

MIC5VMA:AR FROM PDP11		;LOAD A ONE TO BIT08
	BR/AR,J/MIC5VMA		;AND SAVE BIT08 IN THE BR

;BEGIN ACTUAL TESTING MICRO-CODE---SUBTEST 1
VMAS1:	AD/0S,VMA/AD,MEM/AD FUNC		;LOAD VMA(13-35) WITH ZEROES
	SPEC/SP MEM CYCLE,MEM/AD FUNC, AD/B, ADB/BR  ;SET "MCL VMA EXTENDED"
	MEM/WRITE,J/0000		;SET "MCL VMA WRITE"

VMAS2:	COND/LD AR18-35,ADA/MQ,AD/A,AR/AD	;AR 18-35 FILL WITH 1'S
	AD/A, ADA/AR, VMA/AD	;LOAD VMA(13-17)=0, VMA 18-31 NOT=0
	SPEC/SP MEM CYCLE,MEM/AD FUNC,AD/B,ADB/BR  ;SET "MCL VMA EXTENDED"
	MEM/WRITE, AD/0S, AR/AD,J/0000	;SET "MCL VMA WRITE" & SET AR=0

VMAS3:	AD/0S, VMA/AD,MEM/AD FUNC		;LOAD VMA(13-35) WITH ZEROES
	SPEC/SP MEM CYCLE,MEM/AD FUNC,AD/B,ADB/BR  ;SET "MCL VMA EXTENDED"
	MEM/WRITE,		  ;SET "MCL VMA WRITE"
	    SPEC/SP MEM CYCLE,SP MEM/UPT,J/0000 ;SET "MCL PAGE UEBR REF"
VMAS4:	AD/0S, VMA/AD,MEM/AD FUNC		;LOAD VMA(13-35) WITH ZEROES
	SPEC/SP MEM CYCLE, MEM/AD FUNC,	 ;SET "MCL VMA EXTENDED"
		AD/B,ADB/BR, J/0000

.IFNOT/MODEL.B
VMAS5:	AR FROM PDP11	;LOAD AR WITH 37,,0 TO MAKE VMA(13-17)=ALL ONES
.IF/MODEL.B
VMAS7:
VMAS5:	AR FROM PDP11,	;LOAD AR WITH 37,,0 TO MAKE VMA(13-17)=ALL ONES
	    MEM/A RD,#/400	;SET "MCL SR00"
.ENDIF/MODEL.B
	AD/A,ADA/AR,VMA/AD,MEM/AD FUNC  ;VMA GETS 37,,0;SET "MCL VMA READ"
	MEM/LOAD AR		;SET "MCL VMA READ"

.IF/MODEL.B
VMASF:	AR FROM PDP11	;TEST DATA FOR VMA(13-35) LOADED TO AR
	MEM/A RD,#/000,BR/AR	;CLR "MCL SR00,01,02"
	VMA/AD,ADB/BR,AD/B,SPEC/SP MEM CYCLE,MEM/LOAD AR,
	    #/400,J/0000 ;SET "FETCH" & "VMA EXTENDED"
.ENDIF/MODEL.B
;SUBTEST 6 THRU 10 LOOP ON THIS CODE

VMAS5.10:AR FROM PDP11	;TEST DATA FOR VMA(13-35) LOADED TO AR
	VMA/AD,ADA/AR,AD/A,MEM/AD FUNC	;LOAD VMA(13-35)
	SPEC/SP MEM CYCLE,MEM/AD FUNC,AD/A,ADA/AR  ;SET "MCL VMA EXTENDED"
	MEM/WRITE, J/VMAS5.10	;SET "MCL VMA WRITE" & LOOP THE TEST
.TOC	"VMA6:  PREVIOUS SECTION REG, VMA IN MUX, ARMM BITS 13-17"

;MICRO-CODE TO TEST PREVIOUS SECTION REGISTER, VMA IN MUX AND ITS
;INPUTS, AND TEST ARMM BITS 13-17 AND THE SELECTABILITY OF BOTH
;ITS INPUTS.
;BASIC PATH IS!  LOAD A PATTERN INTO THE PREVIOUS SECTION REGISTER
;FROM THE AD. NEXT, READ THE PREVIOUS SECTION CONTENTS VIA
;THE ARMM AND AR. NEXT, PREVIOUS SECTION THRU VMA IN MUX
;INTO THE VMA SECTION. (AT THIS POINT BOTH THE AR AND VMA ARE
;READ AND VERIFIED TO BE CORRECT). NEXT, LOAD ZEROES TO THE
;VMA SECTION VIA THE VMA IN MUX, FROM THE PC SECTION, (AGAIN, VERIFY
;THE RESULTS). THEN REPEAT WITH A NEW PATTERN.

;MAINLINE TEST MICRO-CODE FOR EVMA06 TEST
MIC6VMA:	AR FROM PDP11		;FIRST TEST PATTERN INTO EBOX
	AR/AR		;THIS WORD IS A NOP TO ENABLE BURST MODE OPERATION
	COND/DIAG FUNC,DIAG FUNC/LD PCS+CWSX,  ;LOAD PREV SECT.REGISTER
		AD/A,ADA/AR,AR/ADX
.IFNOT/MODEL.B
	AR CTL/AR9-17 LOAD,COND/REG CTL,  ;PREV SECTION THRU ARMM INTO AR
		AR/ARMM,ARMM/EXP_SIGN
.IF/MODEL.B
	AR CTL/AR9-17 LOAD,COND/REG CTL,  ;PREV SECTION THRU ARMM INTO AR
		AR/ARMM,VMAX/PREV SEC	;THIS PUTS PREV SEC INTO AR
.ENDIF/MODEL.B

.IFNOT/MODEL.B
	COND/SPEC INSTR,SPEC INSTR/PXCT	;SET UP A PXCT TO ENABLE VMA IN MUX
.IF/MODEL.B
	MEM/EA CALC		;DO EA CALC TO ENABLE VMA IN MUX
.ENDIF/MODEL.B

	MEM/A RD,VMA/AD,	;LOAD PREV SEC INTO VMA SEC THRU VMA IN MUX
	    BR/AR		;AND SAVE THE ARMM TO AR DATA IN THE BR

;PDP11 WILL TEST STATUS OF EBOX AT THIS POINT.
; PREV SEC "HOLD ABILITY" WAS ALSO CHECKED BY THIS MICRO-CODE.
	VMA/PC,DISP/DIAG,J/0000 ;CLR VMA SEC.  LOAD FROM PC SEC VIA VMA IN

;AGAIN THE PDP11 WILL CHECK THE EBOX
;NOW THE LAST PHASE OF THE TEST IS TO CHECK THE PC LINES
;THRU THE ARMM MIXER.

M6.1VMA:AR/ARMM,ARMM/#	;PC THRU ARMM INTO AR-CHECK ARMM PC SELECT ABILITY
.IF/MODEL.B
.TOC	"ADDITIONAL AC REF & AC LOCAL ADDR TESTS FOR VMA BOARD"
;IT IS THE PURPOSE OF THIS TEST TO CHECK SEVERAL SIGNALS ON THE VMA 
;BOARD THAT ARE CURRENTLY LOOSE ENDS AND NOT TESTED BY ANYONE.
;THESE INCLUDE INPUTS TO "VMA LOCAL","VMA LOCAL AC ADDRESS", & "VMA AC
;REF"
;SEE THE PDP11 CODE COMMENTS FOR COMPLETE DETAILS ON WHAT SIGNALS ARE
;BEING TESTED BY EACH SUBTEST

MIC8VMA: AR FROM PDP11		;LOAD 36-BIT STIMULUS WORD TO AR

	MEM/A RD,#/400,BR/AR	;SET "MCL SR00" TO PREVENT "VMA EXT EN"

	J/SUPTST,DISP/SIGNS,	;SKIP..AD00=1 SETS "VMA EXTENDED"
	    VMA/AD,AD/B,ADB/BR	;AND LOAD VMA WITH DATA PATTERN

=110
SUPTST:
;HERE IF THERE SHALL BE NO "VMA EXTENDED"
	COND/VMA INC,MEM/EA CALC, ;INCREMENT VMA AND
	    #/42,J/MIC8VMA	;SET "VMA READ" & ENABLE "MCL ADR ERR"

;HERE IF WE REQUIRE "VMA EXTENDED" TRUE
	COND/VMA INC,MEM/EA CALC, ;INCREMENT VMA AND
	    #/42,		;SET "VMA READ" & ENABLE "MCL ADR ERR"
	    J/MIC8VMA,SH/AR	;DUMMY "SH/AR" TO SET "MCL VMA EXTENDED"
.ENDIF/MODEL.B
.TOC	"VMA07: PC & VMA HELD DIAGNOSTIC MIXERS"

;MICRO-CODE FOR LOADING THE "PC" WITH INTERFERENCE DATA FROM THE VMA
;AND THEN LOADING THE "VMA HELD" REGISTER WITH INTERFERENCE DATA FROM
;THE VMA,AND CHECKING BOTH OF THE REGISTERS WHILE YOU DO IT

MIC7VMA:	AR FROM PDP11		;TEST PATTERNS TO AR

	VMA/AD,AD/A,ADA/AR,MEM/AD FUNC,COND/LD VMA HELD	;TEST PATTERN TO VMA
	SPEC/LOAD PC			;TEST PATTERN TO PC
;** PDP11 WILL STOP HERE TO READ THE PC

	COND/LD VMA HELD,	 ;TEST PATTERN TO VMA HELD-0S TO VMA
		VMA/AD,AD/0S,MEM/AD FUNC
	SPEC/LOAD PC,			;ZEROES TO PC
	  J/MIC7VMA		;PDP11 WILL STOPHERE TO READ VMA HELD
;MACRO TO GENERATE "CON CONO PI"
	CONO PI	"COND/DIAG FUNC, DIAG FUNC/CONO PI, ADA/AR,AD/A"
	GEN AR	"ADA/AR,AD/A"

.TOC	"PI LEVEL SET/CLR;PI GEN SET/CLR;PI ON/OFF & PI SYS CLR"

;THE MICRO-CODE FOR PI TEST1 MERELY STROBES THE CONTENTS OF THE
;AR TO THE PI BOARD IN ORDER TO TEST THE SETTING AND CLEARING OF
;BOTH PI "ON LEVELS" AND PI "GEN LEVELS".

MIC1PIZZA:
	AR FROM PDP11		;LOAD CONO DATA TO AR
	AD/0S,ADA/ARX		;INSURE NO DATA READY ON EBUS
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE, ;PREVENT "LOAD/TEST" RING
		AR/AR
	CONO PI			;GIVE THE PI BOARD A GO
	BR/AR,AR/ADX,GEN AR,	;AND CLOCK FOR "CON CONO PI" TO GO AWAY
		J/0000,DISP/DIAG

;THIS CODE IDENTICAL TO "MIC1PIZZA", BUT "CON CONO PI" IS NOT ASSERTED
NOCONO:	AR FROM PDP11		;CONO DATA TO AR
	AD/0S,ADA/ARX		;ZERO EBUS DATA
	COND/SPEC INSTR,	 ;TURN OFF PI "LOAD/TEST" RING
		SPEC INSTR/SET PI CYCLE
	COND/DIAG FUNC,DIAG FUNC/.5 USEC,ADA/AR,AD/A	;PSUEDO CONO
	BR/AR,AR/ADX,AD/0S,
		J/MIC1PIZZA	;LAST CLOCK TICK

.TOC	"PI BOARD IR03-IR09 THRU CS MUX, CS LINES STUCK, ANY INTERFERENCE"

MIC2PI:	AR FROM PDP11		;INTERFERENCE PATTERN TO THE AR
	AD/A,ADA/AR,COND/LOAD IR  ;LOAD IR FROM AD
	AD/0S,ADA/MQ,AR/AD,J/MIC2PI  ;REMOVE DATA AND BACK TO THE BEGINNING

.TOC	"PI BOARD BASIC LOAD/TEST RING, PLUS EBUS REQUEST AND EBUS PI GRANT"

;THE FOLLOWING MICRO SEQUENCE IS USED IN TEST PIZZA2, SUBTESTS 8, 10, & 11.
;THE MICRO CODE FIRST SETS "PI CYCLE".
;SECONDLY, IT DOES A "CONO PI" WITH DATA
;LOADED INTO THE AR FROM THE PDP11.
;THIS DATA SHOULD SET "PI ACTIVE" & "PI GEN4".
;THE SIGNAL "EBOX HALTED" WILL BE LEFT FALSE. THEN MICRO CODE THE LOOPS ON
;A NOP INSTRUCTION WHILE THE PDP11 ISSUES MBOX CLOCKS IN ORDER TO TEST
;AND CHECK THE PI BOARD OPERATION.
MPI2.1:	AR FROM PDP11		;LOAD CONO DATA TO THE AR
	COND/SPEC INSTR,	 ;SET THE PI CYCLE FLOP
		SPEC INSTR/SET PI CYCLE,AR/AR
	CONO PI,J/CLRPIC	;LOAD "ACTIVE" & "GEN" AND GO CLEAR PI CYCLE
;THIS MICRO-CODE SEQUENCE FIRST SETS "PI CYCLE".SECONDLY, DOES A "CONO PI"
;WITH DATA PROVIDED BY THE PDP11 WHICH SHOULD SET "ACTIVE" AND "GEN" 4
;NEXT THE FLOP "EBOX HALTED" WILL BE SET TRUE, FINALLY IT JUMPS TO THE
;NOP LOOP WHILE THE ELEVEN CHECKS THE PI BOARD.
MPI2.2:	AR FROM PDP11		;COND DATA INTO THE AR
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE,AR/AR  ;SET PI CYCLE FLOP
	CONO PI			;LOAD "ACTIVE" & "GEN" 4
	COND/SPEC INSTR,SPEC INSTR/HALTED,  ;SET "EBOX HALTED"
		GEN AR,J/CLRPIC

;THIS MICRO CODE SEQUENCE FIRST SETS "PI CYCLE" THEN SETS
;"APR EBOX DISABLE CS". NEXT, PI CYCLE IS DROPPED AND WE GO TO
;THE NOP MICRO LOOP.
MPI2.5:	AR FROM PDP11		;LOAD CONO DATA TO THE AR
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE
	COND/EBUS CTL,EBUS CTL/DISABLE CS HOLD  ;SET "APR EBOX DISABLE CS"
		J/CLRPIC

CLRPIC:	SPEC/FLAG CTL,FLAG CTL/DISMISS,GEN AR,J/JSELF  ;CLR PI CYCLE FLG
JSELF:	J/JSELF,COND/VMA_#+PI*2	;MICRO NOP TO LOOP ON SELF
				;AND GATE PI4,2,1 TO SCAD MUXS
.TOC	"PI BOARD TEST 3, PIR EN, PI REQ SET, PIH, PI CLRS"

;THIS MICRO-CODE IS USED TO TEST THE "PI REQ SET" DECODER SYSTEM,
;THE PIH FLIP FLOPS, AND THE "PI DISMISS" DECODER SYSTEM

MIC3PI:	AR FROM PDP11		;LOAD CONO DATA TO THE AR
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE,AR/AR  ;SET PI CYCLE FLOP
	CONO PI			;SET GEN LEVEL IN ORDER TO SET A PI REQ
	SPEC/FLAG CTL,FLAG CTL/DISMISS,  ;DROP PI CYCLE
		GEN AR		;AND START LOAD/TEST RING COUNTER
	TIME/3T		;WAIT 3 MTICS SO THE PI BOARD CAN SET THE REQUEST
	TIME/2T			;ADDITIONAL TICS NEEDED FOR PI TO SET
;*******
;THE PDP11 WILL STOP THE CLOCK HERE IN ORDER TO READ STATE OF PI BOARD
;*******
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE  ;SET PI CYCLE AGAIN
	SPEC/SAVE FLAGS		;SET PI HOLD FLOPS & CLEAR PI CYCLE
;*******
;THE PDP11 WILL STOP THE CLOCK HERE IN ORDER TO READ STATE OF PI BOARD
;*******
	SPEC/FLAG CTL,FLAG CTL/DISMISS  ;DISMISS PI HOLD ON HIGHEST LEVEL
	J/MIC3PI		;NOW LOOP TO BEGINNING
;*******
;THE PDP11 WILL STOP THE CLOCK TO READ THE STATE OF THE PI BOARD.
.TOC	"PI BRD TST 3,PIH/PIR DUAL PRIORITY ENCODERS OF REQUEST ON LEVEL"

;THE PIH FLOPS ARE NOW SET, NOW WE MUST SET THE PIR FLOPS
M3.1PI:	AR FROM PDP11		;CLEAR GEN LEVEL CONO DATA TO THE AR
	TIME/2T			;NEED RAM WORD TO BUFFERR THE CONO
	CONO PI			;CLEAR CURRENT GEN STATUS

	AR FROM PDP11,GEN AR	;CONO DATA TO SET APPROPRIATE PIR FLOPS
	TIME/2T,COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE,AR/AR
	CONO PI			;SET REQUIRED GEN LEVELS
	SPEC/FLAG CTL,FLAG CTL/DISMISS,  ;DROP PI CYCLE TO SET PIR FLOPS
		GEN AR
	TIME/3T,DISP/DIAG,J/0000	;NOW ISSUE PI DISMISS ONLY IF NEEDED
PI3.1A:	TIME/5T,SPEC/FLAG CTL,FLAG CTL/DISMISS,J/PI3.1C ;DISMISS A PIH
PI3.1B:	TIME/5T			;4 MORE MBOX TICS
;******	PDP11 NOW CHECKS CURRENT PI BOARD STATE
PI3.1C:	COND/VMA_#+PI*2		;GATE "PI4,PI2,PI1" TO SCD MIXER

;MICRO CODE SUBROUTINE TO LOAD MORE THAN ONE OF THE PIH FLOPS
;AND FINISH UP WITH A DISPATCH "DISP/DIAG" SO THAT THE MAINLINE
;PDP11 CODE CAN TAKE OVER AGAIN AND CONTINUE ITS TEST, ONLY
;NOW WITH MULTIPLE PIH FLOPS SET
M3SUB1:	AR FROM PDP11		;LOAD CONO DATA TO THE AR
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE,AR/AR  ;SET PI CYCLE FLOP
	CONO PI			;SET GEN LEVEL IN ORDER TO SET A PI REQ
	SPEC/FLAG CTL,FLAG CTL/DISMISS,  ;DROP PI CYC,START LOAD/TEST RING
		GEN AR
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE  ;SET PI CYCLE AGAIN
	SPEC/SAVE FLAGS		;SET PI HOLD FLOPS & CLEAR PI CYCLE
	TIME/2T,DISP/DIAG,J/000 ;ADDITIONAL TICS NEEDED FOR PI TO SET
.TOC	"PI BOARD TEST 4:PI TIME STATE COUNTER & TIMER DONE BINARY COUNTER"

;THIS MICRO-CODE SETS UP THE PI BOARD TO START THE PI TIME STATE COUNTER
;AND THEN LOOPS ON ITSELF WHILE THE PDP11 ISSUES CLOCKS AND EXAMINES THE
;PI BOARD AS IT CYCLES THRU ITS TIME STATES

MIC4PI:	AR FROM PDP11		;START WITH CONO DATA TO THE AR
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	CONO PI			;SET GEN LEVEL TO FORCE PI TIME STATE GO
	SPEC/FLAG CTL,FLAG CTL/DISMISS,  ;DROP PI CYC,START LOAD/TEST RING
		GEN AR
	TIME/5T,AR/AD,ADB/AR*4,AD/B  ;SET "EBUS PI GRANT",START "TIM1"
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE  ;PI CYCLE AGAIN FOR "TIM6"
	CONO PI			;AND DO A CONO TO CLEAR THE "GEN7" JUST SET
	TIME/2T,GEN AR		;TWO TICS INTO "TIM3"
	CONO PI			;AND DO A CONO TO CLEAR THE "GEN7" JUST SET
MPI4.1:	J/MPI4.1,GEN AR		;LOOP HERE WHILE PDP11 CONTROLS THE TEST
.TOC	"EBOX CONTROL OF PI:PI CYC,EBOX HALTED,EBUS REQ,REL,DEMAND,&RETURN"

;THIS TEST CLOCKS THROUGH THE TIME STATES OF THE PI BOARD, WHILE AT THE
;SAME TIME BRINGING UP CONTROL SIGNALS AND SETTING CONTROL FLOPS IN THE EBOX
;WHICH SHOULD EXERCISE CONTROL OVER THE PI BOARD,
;FORCING THE PI BOARD TO HOLD
;TIME STATES AND RELEASE OR ACCEPT CONTROL OF THE EBUS.

;THE BEGINNING TESTS WILL CHECK THE "PI GRANT" & "CP GRANT" NETWORKS
;THE FIRST SUBTEST WILL SET "CP GRANT",
;TRY TO SET "PI GRANT" (CP GRANT SHOULD DISABLE PI GRANT)
;AND THEN ISSUE AN "EBUS REL" TO CLEAR "CP GRANT".
MIC5PI:	AR FROM PDP11		;LOAD CONO PI GEN DATA TO AR
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	COND/EBUS CTL, EBUS CTL/REQ EBUS  ;SET "APR EBUS REQ"
	CONO PI			;CONO PI SETS "PI REQ" & "CON EBUS GRANT"
	SPEC/FLAG CTL,  ;DROP PI CYC,START PI LOAD/TEST RING&TEST EBUS GRANT
		FLAG CTL/DISMISS,SKIP/-EBUS GRANT,GEN AR
=1
	COND/EBUS CTL,EBUS CTL/REL EEBUS, ;CLOCK,CHECK "PI GRANT" NOT SET
		TIME/5T
	COND/EBUS CTL,EBUS CTL/REL EBUS ;RELEASE EBUS,VERIFY "CP GRANT" CLRS
M5.0PI:	TIME/2T		;ADDITIONAL TIC FOR "CON EBUS GRANT" TO CLEAR
	SKIP/-EBUS GRANT
;THE NEXT SUBTEST WILL COMPLETE THE TEST
;OF THE D-INPUT TO THE "CP GRANT" FLOP
M5.1PI:	AR FROM PDP11		;LOAD CONO PI GEN DATA TO AR
	SKIP/-EBUS GRANT, ;CHECK THAT "-APR EBUS REQ",INHIBITS  CP GRANT
		TIME/2T
=1
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE
	CONO PI		  ;DO A CONO & READ "CP GRANT"
	SPEC/FLAG CTL,FLAG CTL/DISMISS,GEN AR
=1
	TIME/5T			;AND SET "PI5 EBUS PI GRANT"
	COND/EBUS CTL, EBUS CTL/REQ EBUS  ;SET APR EBUS REQ
	TIME/2T			;AND SEE THAT "EBUS CP GRANT" DOES NOT SET
	TIME/2T,SKIP/-EBUS GRANT
;THE NEXT SEVERAL SUBTESTS ARE DESIGNED TO TEST THE "EBUS DEMAND" LOGIC
M5.2PI:	AR FROM PDP11		;LOAD CONO PI GEN DATA TO AR
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	CONO PI			;SET GEN LEVEL,FORCE PI TIME STATE TO GO
	SPEC/FLAG CTL,  ;DROP PI CYCLE TO START LOAD/TEST TIMING
		FLAG CTL/DISMISS,GEN AR
	TIME/5T			;SET "EBUS PI GRANT"
	COND/EBUS CTL, EBUS CTL/EBUS DEMAND  ;SET "APR EBUS DEMAND"
;THE ELEVEN WILL STOP HERE AND CHECK THAT "EBUS DEMAND E" HAS GONE HIGH.
	COND/EBUS CTL, EBUS CTL/EBUS NODEMAND,  ;CLEAR "APR EBUS DEMAND"
		J/JSELF		;AND GOTO A SELF LOOP
;THE NEXT SUBTEST IS THE FINAL PATTERN NECESSARY
;TO COMPLETE THE TEST OF THE EBUS DEMAND
;LOGIC. THIS SUBTEST REQUIRES THE USE
;OF "-HONOR INTERNAL" TO GET TO PI TIME STATE "TIM5"
;AND TEST "EBUS DEMAND"
M5.3PI:	AR FROM PDP11		;LOAD CONO PI GEN DATA TO AR
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	CONO PI			;SET GEN LEVEL,FORCE PI TIME STATE GO
	SPEC/FLAG CTL,FLAG CTL/DISMISS,  ;DROP PI CYC,START LOAD/TEST RING
		GEN AR
	TIME/5T, AR/AD, ADB/AR*4, AD/B  ;SET "EBUS PI GRANT"
	CONO PI,		;CONO TO CLEAR GEN&DROP "HONOR INTERNAL"
		J/JSELF		;AND GO TO A SELF LOOP
;THE NEXT GROUP OF SUBTESTS TEST THE "STATE HOLD" LOGIC
M5.4PI:	AR FROM PDP11		;LOAD CONO PI GEN DATA TO AR
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	CONO PI			;SET NECESSARY GEN LEVEL TO FORCE A "PI REQ"
	SPEC/FLAG CTL,  ;DROP PI CYCLE TO START LOAD/TEST TIMING
		FLAG CTL/DISMISS,GEN AR
	TIME/3T			;SET "PI EBUS GRANT"
	COND/SPEC INSTR,  ;SET PI CYCLE FOR NEXT SUBTEST
		SPEC INSTR/SET PI CYCLE,
	J/JSELF	;CLEAR GEN PREVIOUSLY SET & LOOP
;THE PDP11 WILL STOP HERE TO CHECK THE STATE OF
;THE PI BOARD (IF COUNTER GOES TO TIMER DONE, ALL OK)
;PDP11 WILL AGAIN CHECK THE PI BOARD.
;IF WE GET THRU TIM6 INTO TIM7, STATE HOLD CHECKS OK

;NEXT STATE HOLD SUBTEST
M5.5PI:	AR FROM PDP11		;LOAD CONO PI GEN DATA TO AR
	COND/SPEC INSTR, SPEC INSTR/HALTED  ;SET "APR EBOX HALTED"
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	CONO PI		;SET NECESSARY GEN LEVEL TO FORCE "PI REQ"
	COND/EBUS CTL,EBUS CTL/GRAB EEBUS,GEN AR  ;SET "APR EBUS RETURN"
	SPEC/FLAG CTL,  ;DROP PI CYCLE TO START LOAD/TEST TIMING
		FLAG CTL/DISMISS
M5.5SF:	TIME/5T,J/M5.5SF	;SET "EBUS PI GRANT"
;PDP11 WILL CHECK PI BOARD.
;SHOULD NOT ENTER "TIM1", SHOULD NEVER GET "TIMER DONE"
;NEXT STATE HOLD SUBTEST
M5.6PI:	AR FROM PDP11		;LOAD CONO PI GEN DATA TO AR
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	CONO PI			;SET NECESSARY GEN LEVEL TO FORCE "PI REQ"
	SPEC/FLAG CTL,  ;DROP PI CYCLE TO START LOAD/TEST RING TIMING
		FLAG CTL/DISMISS,GEN AR
	TIME/5T			;LET PI GET INTO CYCLE THEN SET "HALTED"
	TIME/5T		;SET "EBUS PI GRANT"
	COND/SPEC INSTR, SPEC INSTR/HALTED,  ;SET "CON EBOX HALTED"
		J/JSELF		;AND LOOP

;FINAL STATE HOLD SUBTEST - THIS MICRO-CODE ALSO USED IN SEVERAL SUBTESTS
;TO TEST THE "OK ON HALT" DECODER ON PRINT PI4
M5.7PI:	AR FROM PDP11		;EBUS DATA FOR THE "OK ON HALT" TEST
	BR/AR			;SAVE IT IN BR
	AR FROM PDP11		;CONO PI GEN DATA TO THE AR
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	CONO PI			;SET NECESSARY GEN LEVEL TO SET "PI REQ"
	SPEC/FLAG CTL, FLAG CTL/DISMISS,  ;GET "OK ON HALT" DATA INTO AR
		GEN AR
	TIME/5T,BR/AR,AD/B,ADB/BR*2,AR/AD ;LET PI BOARD GET INTO CYCLE
	TIME/5T			;THIS 5 TIC NOP MAKES PI "TIM6" HAPPEN
				;  AT THE BEGINNING OF A 17 TIC "CONO"
	TIME/5T			;AND START PI LOAD/TEST TIMER
	COND/SPEC INSTR, SPEC INSTR/HALTED  ;SET "APR EBOX HALTED"
M5.8PI:	COND/DIAG FUNC,DIAG FUNC/.5 USEC, ;DUMP "OK ON HALT" ONTO EBUS
		ADA/AR,AD/A,J/M5.8PI
;FINALLY, PDP11 WILL CHECK THAT "OK ON HALT"
;CAUSES "STATE HOLD" AND THAT WE NEVER LEAVE "TIM6"
.TOC	"PI  TEST 6: PHYSICAL NUMBER FLOPS,PHYS. NO. PRIORITY ENCODERS"

;THIS TEST CHECKS THE 16 PHYSICAL NUMBER FLIP FLOPS ON PRINT PI2 AND
;ALSO CHECKS THE DUAL PRIORITY ENCODERS WHICH TAKE THE PHYSICAL NUMBERS AND
;PRODUCE THE SIGNALS "SEL PHY 8, SEL PHY 4, SEL PHY 2, AND SEL PHY 1".
;THE TEST ALSO CHECKS THE "SEL PHY X" TO EBUS BITS 7, 8, 9, 10 MIXER
;THE TEST USES MICRO-CODE WHICH RUNS THROUGH ALL 7 TIMING STATES OF
;THE PI BOARD. THE PDP11 STOPS THE CLOCK DURING PI TIM3 AND EXAMINES
;THE STATE OF THE PI BOARD TO ENSURE THAT THE CORRECT PHYSICAL NUMBERS
;HAVE COME UP. NEXT, THE TEST IS CONTINUED TO TIM6, WITH THE AR FUNCTION
;"AR/EBUS" AND AFTER TIM6 THE PDP11 AGAIN STOPS THE CLOCK AND EXAMINES THE
;PI BOARD & THE AR TO BE SURE THE CORRECT SIGNALS WERE PUT ONTO THE EBUS
;BY THE PI TO EBUS MIXER.

MIC6PI:	AR FROM PDP11		;LOAD PHYSICAL NUMBER TEST PATTERN TO AR
	BR/AR			;TRANSFER TO BR
	AR FROM PDP11		;LOAD CONO PI GEN LEVEL TO START A CYCLE
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	CONO PI			;SET GEN LEVEL,FORCE PI TIME STATE GO
	SPEC/FLAG CTL,  ;DROP PI CYCLE & ACTUALLY START LOAD/TEST TIMING
		FLAG CTL/DISMISS,GEN AR
	AR/AD,AD/B,ADB/BR,  ;SET "EBUS PI GRANT",GET PHYS NUMBER DATA TO AR
		TIME/5T
	TIME/5T  ;PI CYCLE HOLDS TIM6 
	TIME/5T			;MORE MBOX TICS
	TIME/5T			;PLUS 5 MORE
	TIME/5T			;AND FIVE MORE IS PERFECT
	COND/DIAG FUNC,DIAG FUNC/.5 USEC,GEN AR ;PHYSICAL NUMBERS ONTO EBUS
;THE PDP11 STOPS THE CLOCK HERE TO EXAMINE THE PI BOARD AND CHECK
;THAT THE DESIRED PHYSICAL NUMBERS HAVE SET
M6.1PI:	J/M6.1PI, AR/EBUS	;HAVE AR STROBING EBUS TO CHECK WHAT
				;THE PI BOARD PUTS ON THE EBUS AT TIM6
;THE PDP11 STOPS THE CLOCK AFTER "TIM6" TO SEE WHAT THE AR HAS READ OFF
;THE EBUS AT "PI TIM6"
;THE FOLLOWING SECTION OF MICRO-CODE PERFORMS
;TWO ADDITIONAL SUBTESTS FOR PI TEST 6.
;THE FIRST IS TO TEST THE "AND" GATE DRIVING
;THE SELECT INPUT OF THE PHYS. NO. TO EBUS
;MIXER. THE MICRO-CODE WILL GO THROUGH A
;NORMAL SEL PHYS. NO. SEQUENCE LIKE THE
;PREVIOUS SUBTEST, BUT WILL ALSO DO AN
;"EBUS RETURN" TO CHECK THAT THE EBUS RETURN
;TURNS OFF THE DATA ONTO THE EBUS. IMMEDIATELY FOLLOWING THAT SUBTEST, THE
;MICRO-CODE WILL SET "APR EBOX DISABL CS" AND THE PDP11 WILL CHECK THAT THE
;DUAL "PHY. NO." PRIORITY ENCODERS SELECT ALL 0'S.
M6.2PI:	AR FROM PDP11		;LOAD PHYSICAL NUMBER 15 (EBUS BIT15) TO AR
	BR/AR			;TRANSFER TO BR
	AR FROM PDP11		;LOAD GEN LEVEL DATA TO START A PI CYCLE
	COND/SPEC INSTR,  ;SET PI CYCLE TO INITIALIZE LOAD/TEST RING
		SPEC INSTR/SET PI CYCLE
	CONO PI			;SET GEN LEVEL,FORCE PI TIME STATE GO
	SPEC/FLAG CTL,  ;DROP PI CYCLE & ACTUALLY START LOAD/TEST TIMING
		FLAG CTL/DISMISS,GEN AR
	AR/AD,AD/B,ADB/BR,  ;SET "EBUS PI GRANT",GET PHYS NUMBER DATA TO AR
		TIME/5T
	TIME/5T  ;NOW NEED TO WAIT SEVERAL M-TICS FOR PI BOARD
	TIME/5T		;PLUS 5 MTICS
	TIME/5T		;PLUS 5 MORE MTICS
	TIME/5T		;MAKE "TIM3" HAPPEN WHILE EBOX PUTS DATA ON EBUS
	COND/DIAG FUNC,  ;THIS RAM WORD TAKES 21 MTICS,GOES TO "PI TIM5"
		DIAG FUNC/.5 USEC,AD/A,ADA/AR
	 COND/EBUS CTL,  ;5 MORE TICS PUTS US IN TIM6, SET "EBUS RETURN"
		EBUS CTL/GRAB EEBUS
	COND/DIAG FUNC,DIAG FUNC/.5 USEC,  ;THIS MICRO WORD TAKES 21 MTICS
		AD/0S
	TIME/5T			;WAIT 5 MORE MTICS
	TIME/5T
	TIME/5T
	AR/EBUS		;EBUS INTO AR,ENSURE "EBUS RETURN" TURNS OFF
			;PHYS. NO. TO EBUS-PDP11 CHECKS KL10 HERE
	COND/EBUS CTL,  ;SET "APR EBOX DISABLE CS" & ENSURE IT TURNS OFF
			;PHYS NUMBER DUAL PRIORITY ENCODERS
		EBUS CTL/DISABLE CS HOLD
	J/JSELF			;AND END WITH A NOP LOOP
.TOC	"PI BOARD - TEST 7, APR PIA 04,02,01, APR PHY NO. & PIR EN"
;MACRO FOR CONO APR
CONO APR	"COND/DIAG FUNC, DIAG FUNC/CONO APR, ADA/AR, AD/A"
;IT IS THE PURPOSE OF THIS TEST TO CHECK THE "APR PIA04,02,01" FLPS, WHICH
;ARE SET BY THE "CONO APR", TO CHECK THE "APR PIA" DECODERS AND TO CHECK
;THE OUTPUT OF THE "APR PIA" DECODERS TO THE PI REQUEST FLOPS
;THE TEST PERFORMS THE TEST BY 1) SETTING ALL PI LEVELS "ON" & "PI ACTIVE".
;2) THEN SETTING THE 3-BIT "APR PIA" REGISTER WITH 0, CYCLING THE PI
;BOARD TO "TIM3", THEN REPEATING THAT LOOP, ONLY LOADING THE "APR PIA"
;WITH 1 THRU 7, THIS MEANS WE ALSO CHECK THE "APR REQUESTING" FLIP FLOP
MIC7PI:	AR FROM PDP11		;LOAD DATA FOR "APR PIA 04,02,01"
	ARX/AD,AD/A,ADA/AR	;MOVE IT TO ARX
	AR FROM PDP11		;SET "ACTIVE" & ALL LEVELS "ON"
	COND/SPEC INSTR, SPEC INSTR/SET PI CYCLE  ;SET PI CYCLE
	CONO PI			;SET "PI ACTIVE", SET ALL PI LEVELS "ON"
	AR/SH,SH/ARX,GEN AR  ;NOW GET APR DATA TO AR
	CONO APR,		;SET "APR PIA 04,02,01" FLOPS
	     J/CLRPIC		;AND GO START PI "LOAD/TEST" RING
.TOC	"PI TEST 8, MTR PIA04, 02, 01, MTR PHY NO. & PIR0, DTE20 PI REQ0"
;MACRO FOR CONO MTR
CONO MTR      "SPEC/MTR CTL,COND/DIAG FUNC,DIAG FUNC/CONO MTR,AD/A,ADA/AR"
CONO TIM      "SPEC/MTR CTL,COND/DIAG FUNC,DIAG FUNC/CONO TIM,AD/A,ADA/AR"
;IT IS THE PURPOSE OF THIS TEST TO CHECK
;THE "MTR PIA04, 02 01" FLOPS, WHICH ARE
;SET BY THE "CONO MTR" WHICH IS GENERATED
;ON THE MTR BOARD. TO CHECK THE MTR
;PIA DECODERS AND TO CHECK THE OUTPUT OF
;THE "MTR PIA" DECODERS TO THE PI REQUEST
;FLOPS. THE TEST ALSO CHECKS THE "DK20 REQUESTING" FLOP ON THE PI BOARD.
;THE TEST  1) SETS ALL PI LEVELS ON & PI ACTIVE.
;  2) SETS THE "MTR PIA" REGISTER WITH (1-7),
;THEN CYCLES THE PI BOARD TO "TIM3",
;WHICH SHOULD SET THE "DK20 REQUESTING"
;FLOP. THE CYCLING SHOULD ALSO SET A PI REQUEST.

MIC8PI:	AR FROM PDP11		;CONO PI DATA TO SET ACTIVE & PI LEVELS ON
	COND/SPEC INSTR, SPEC INSTR/SET PI CYCLE  ;SET PI CYCLE
	CONO PI			;ACTUALLY SET "ACTIVE" & "ON"
	AR FROM PDP11,GEN AR	;CONO TIM DATA TO THE AR
	BR/AR			;MOVE IT TO BR
M8.0PI:	AR FROM PDP11		;GET CONO MTR DATA TO THE AR
	CONO	MTR		;SET "MTR PIA" FLOPS
	AR/AD, AD/B, ADB/BR	;NOW "CONO TIM" DATA TO AR.
	CONO TIM,		;SET "MTR VECTOR INTERRUPT" FLOPS
	   J/CLRPIC		;AND GO START PI "LOAD/TEST" RING
;THIS NEXT SECTION OF MICRO-CODE IS USED IN 3 SUBTESTS AND ITS SOLE
;PURPOSE IS TO CHECK THE SINGLE "AND" GATE WHICH PRODUCES "PI ON 0 4"
;AND "PI ON 0" AS IT AFFECTS THE "PI5 EBUS REQ" LOGIC
;THE MICRO CODE SETS "EBOX HALTED" THEN GENERATES PI REQUESTS WHICH SHOULD
;BE DISABLED BY "EBOX HALTED". HOWEVER, IF THE "PI ON 0" CIRCUITS ARE BAD,
;THE REQUEST CAN GET THROUGH. IF THE REQUEST DOES GET THROUGH, THE HARDWARE
;FAILURE IS LOCALIZED TO TWO GATES.

M8.1PI:	AR FROM PDP11		;LOAD CONO PI DATA TO THE AR
	COND/SPEC INSTR, SPEC INSTR/SET PI CYCLE  ;SET PI CYCLE FLOP
	CONO PI			;SET THE DESIRED GEN LEVELS
	COND/SPEC INSTR, SPEC INSTR/HALTED,  ;SET "CON EBOX HALTED"
		GEN AR,J/CLRPIC	;CLEAR PI CYCLE & SEE IF REQUEST GENERATED
;THIS FINAL PIECE OF MICRO-CODE LOOPS ON ITSELF WAITING TO
;HAVE A REQUEST GENERATED. WHILE IT IS LOOPING, THE PDP11 WILL GENERATE
;A REQUEST ON LEVEL 0. THE PDP11 THEN STOPS THE CLOCK AND CHECKS TO
;SEE THAT THE PI BOARD REACTED TO THE REQUEST

M8.2PI:	AR FROM PDP11		;LOAD CONO PI DATA TO THE AR
	COND/SPEC INSTR, SPEC INSTR/SET PI CYCLE  ;SET PI CYCLE FLOP
	COND/EBUS CTL,  ;SET "APR EBUS REQ" (& ALSO "PI EBUS CP GRANT")
		EBUS CTL/REQ EBUS
	COND/SPEC INSTR, SPEC INSTR/HALTED
	CONO PI,		;TURN OFF ACTIVE & ALL LEVELS
		J/CLRPIC	;CLR PI CYCLE TO LET PIR0 INTO PI SYSTEM
.TOC	"ECLK6: CLOCK PAGE FAIL LOGIC MICROCODE"

;FIRST KICKOFF A MEMORY CYCLE

.IFNOT/MODEL.B
CLKM00:	MEM/A IND, J/CLKM01
.IF/MODEL.B
CLKM00:	MEM/EA CALC, J/CLKM01
.ENDIF/MODEL.B


;THEN FORCE A PAGE FAIL

CLKM01:	COND/MBOX CTL, MBOX CTL/SET PAGE FAIL, J/CLKM02

;THIS LOCATION IS A TRAP SHOULD THE PAGE FAIL NOT OCCUR

CLKM02:	J/CLKM02

;THIS IS THE LOCATION REACHED AFTER A SUCCESSFUL P.F. DISPATCH

;3:	J/3    THIS WAS ALREADY DONE AT THE BEGINNING

;AND THIS IS THE LOCATION FORCED BY THE PAGE FAIL LOGIC

1777:	DISP/PG FAIL, J/0
.TOC	"ECLK7: CLOCK BOARD'S MB WAIT AND SIMULATED MB RESP LOGIC"

;DO A MEM/LOAD AR TO START A MEMORY CYCLE

CLKM10:	MEM/LOAD AR,  J/CLKM11

;THEN DO AN MEM/MB WAIT

CLKM11:	MEM/MB WAIT, J/CLKM11
.TOC	"ESCD1 & 2: BASIC SCD 10-BIT ARITHMETIC DATA PATH TEST MICROCODE"

;LOAD THE SC FROM AR 18 AND 28-35, THEN COMPLIMENT AR

SCM00:	AD/SETCA,ADA/AR,ADA EN/EN,AR/AD,
	SCAD/A,SCADA EN/0S,SCADB/SC,SC/AR SHIFT,
	SPEC/SCM ALT,
	J/SCM01

;RECIRCULATE THE SC AND AR

SCM01:	J/SCM02

;LOAD SC FROM AR, FE FROM SC AND AR FROM SC

SCM02:	AR/ARMM,ARMM/SCAD EXP,
	SCAD/A+B,SCADA EN/0S,SCADB/SC,SC/AR SHIFT,FE/SCAD,
	SPEC/SCM ALT,COND/LD AR0-8,
	J/SCM03

;LOAD SC FROM FE, RECIRCULATE FE AND AR 0-8 FROM SC

SCM03:	AR/ARMM,ARMM/SCAD EXP,
	SCAD/A+B,SCADA EN/0S,SCADB/SC,SC/FE,
	SPEC/SCM ALT,COND/LD AR0-8,
	J/SCM04

;LOAD SC FROM AR, SHIFT FE RIGHT AND AR 0-8 FROM FE


SCM04:	AR/ARMM,ARMM/SCAD EXP,
	SCAD/A,SCADA/FE,SCADB/SC,SC/AR SHIFT,
	SPEC/SCM ALT,COND/FE SHRT,MEM/ARL IND,#/200,
	J/SCM05

;SC RECIRCULATES, SHIFT FE RIGHT AND AR 0-8 FROM SCAD POS

SCM05:	AR/ARMM,ARMM/SCAD POS,
	SCAD/A+B,SCADA EN/0S,SCADB/SC,
	COND/FE SHRT,MEM/ARL IND,#/200,
	J/SCM00

.TOC	"ESCD5: 10-BIT ADDER TEST MICROCODE"

;LOAD FE FROM MAGIC # FIELD, SIGN EXTENDED

SCM10:	SCAD/A,SCADA/#,FE/SCAD,
	J/SCM11

;LOAD SC FROM MAGIC # FIELD, SIGN EXTENDED - FE RECIRCULATES

SCM11:	SCAD/A,SCADA/#,SC/SCAD,
	J/SCM12

;DO ADDER FUNCTION OF SC AND FE, SAVE RESULT IN BOTH SC AND FE

SCM12:	SCADA/FE,SCADB/SC,FE/SCAD,SC/SCAD,
	J/SCM13

;SWITCH ADDER MUXES TO CUT OFF SLOW SIGNALS

SCM13:	SCADA/#,SCADB/#,
	J/SCM10
.TOC	"APR FM 36 PARITY RAM CHIP TEST"

;THE MICRO-CODE FOR THIS TEST IS FAIRLY SIMPLE. FIRST IT LOADS
;A 36-BIT WORD TO THE AR THAT HAS BOTH FM BLOCK NUMBER AND
;FM AC NUMBER. A SPECIAL FUNCTION IS EXECUTED TO LOAD THE BLOCKS,
;THEN DATA IS WRITTEN TO THE FM WITH EITHER "EVEN PARITY" TURNED
;ON OR ELSE WITH EVEN PARITY TURNED OFF (DEPENDING ON WHETHER OR
;NOT WE WANT TO WRITE ZEROES OR ONES TO FM36). THE PDP11
;TAKES OVER AND CHECKS THE RAM CHIP, THEN SELECTS THE DESIRED
;NEXT FM ADDRESS, AND THE MICRO CODE LOOP IS REPEATED
MPAR1:	AR FROM PDP11,ADB/FM	;DATA TO AR SETS OR CLRS "WR EVEN PAR DATA"
	TIME/2T			;KEEP RAM CODE IN SYNC WITH SINGLE CLOCKS
	CONO PI			;SET OR CLR "WR EVEN PAR DATA"
	TIME/2T			;WORD SO CLOCK CAN SYNC

MPAR1A:	AR FROM PDP11,	;DATA TO AR TO SET AC BLKS & FM ADDR
		ADB/FM,FMADR/XR,AD/0S,ARX/AD	;CLEAR ARX TOO
	TIME/2T			;RAM CODE STAYS IN SYNC WITH SINGLE CLOCKS
	COND/DIAG FUNC,DIAG FUNC/LD AC BLKS,  ;LOAD AC BLOCKS
	    FMADR/AC0,AD/A,ARX/SH,AR/ADX,ADA/AR,BR/AR,SH/AR	;CLEAR AR (GIVES "-SH EXTENDED")
	FMADR/XR,ADB/FM,COND/FM WRITE,  ;WRITE PARITY & DATA TO FM
		AD/0S,BRX/ARX,J/MPAR1A
.TOC	"PARITY TEST -- CON AR 36, CON ARX 36"

;THIS MICRO-CODE IS USED IN THE PARITY TEST TO CHECK
;THE "CON AR 36" & "CON ARX 36" LOGIC.
;UNDER CONTROL OF THE PDP11, THIS MICRO-CODE IS USED
;TO SET OR CLEAR THE "FM 36" BIT,
;THE "WR EVEN PAR DATA" FLOP, THE "MBOX DATA" FLOP,
;THE "FM DATA" FLOP, THE "AR FROM MEM"
;FLOP & THE "ARX LOADED" FLOP. THESE FLOPS ARE SET
;ACCORDING TO TEST PATTERNS.
;REQUIRED FOR THE "AR/ARX 36" AND THEN THE PDP11
;READS ALL OF THE RELATED PARITY SIGNALS
;TO VERIFY CORRECT OPERATION OF THE LOGIC.
MPAR2:	AR FROM PDP11,ADB/FM		;DATA TO AR MAKES ODD OR EVEN PARITY
	FMADR/XR, COND/FM WRITE	;WRITE FM & BIT "FM 36"

	AR FROM PDP11		;CONO PI DATA FOR "CON WR EVEN PAR DATA"
	CONO PI			;SET OR CLR "WR EVEN PAR DATA" BIT

	AR FROM PDP11		;DATA TO BE LOADED TO VMA
	VMA/AD, ADA/AR, AD/A	;CAUSE "VMA AC REF" OR "-VMA AC REF"


	AR FROM PDP11		;ARX PARITY TEST DATA TO EBOX
	ARX/AD, AD/A, ADA/AR,DISP/DIAG,J/000	;ARX PARITY DATA TO ARX

DPARX1:	MEM/LOAD AR,J/PAR2GO
DPARX2:	MEM/LOAD ARX,J/PAR2GO
PAR2GO:	MEM/MB WAIT,ADB/AR*4,AD/B, ;TIC FOR "CON" FLOPS TO SET
		AR/AD*.25 ;USE "AR/AD*.25 TO AVOID HARDWARE FORCED "AR/EBUS"

.IFNOT/MODEL.B
	TIME/2T, J/MPAR2,ADB/FM	;CLOCK TO SET "FM DATA","MBOX DATA" ETC.
.IF/MODEL.B
	TIME/3T, J/MPAR2,ADB/FM	;CLOCK TO SET "FM DATA","MBOX DATA" ETC.
.ENDIF/MODEL.B
.TOC	"AR OR ARX PARITY PAGE FAIL, FM PARITY CHAIN, FM PARITY STOP"

;THIS MICRO-CODE IS USED TO TEST THE "CLK PAGE FAIL" LOGIC AS
;CAUSED BY BAD AR PARITY OR BAD ARX PARITY AND "CLK PF DISP 09" & "10"
;AS CAUSED BY THE SAME BAD PARITY. IT ALSO IS USED TO TEST THE FAST MEMORY
;PARITY CHAIN, & FINALLY THE "CLK ERROR HOLD" AS CAUSED BY BAD FM PARITY.
;	THE TEST LEAVES "CON AR 36" & "CON ARX 36" IN THEIR DEFAULT
;STATES, "TRUE" AND THEN LOADS A BIT TO THE AR (OR ARX) WHICH MAKES
;PARITY ODD FALSE, OR ELSE CLEARS THE AR (ARX) WHICH MAKES
;PARITY ODD TRUE. WHILE DOING THIS, "AR LOADED" AND "ARX LOADED"
;ARE RAISED AND LOWERED AS NEEDED BY THE TEST PATTERN AND WHEN THIS IS ALL
;SET UP, THE STATE OF ALL RELEVANT PARITY BITS IS CHECKED, INCLUDING
;"CLK PAGE FAIL".
;	THE SECOND PHASE OF THE TEST CHECKS THE FM PARITY CHAIN
;BY LOADING THE AR WITH THE APPROPRIATE TEST PATTERN, WRITING THE DATA
;TO THE FM, THEN READING THE ASSOCIATED PARITY BITS.
MPAR3:	AR FROM PDP11		;ARX PARITY DATA TO AR
	ARX/AD, AD/A, ADA/AR	;ARX PARITY DATA TO ARX

	AR FROM PDP11		;AR PARITY DATA TO AR
	DISP/DIAG,J/000,COND/FM WRITE	;DISPATCH TO "LOAD AR" OR "LOAD ARX"
DPARY1:	MEM/LOAD AR,J/PAR3GO
DPARY2:	MEM/LOAD ARX,J/PAR3GO
PAR3GO:	MEM/MB WAIT		;ADDITIONAL TIC FOR "CON" FLOPS TO SET
	TIME/2T,DISP/PG FAIL,  ;AND READ PAGE FAIL BITS THRU C.R.A.
		ADB/FM,J/0000
;MICRO-CODE FOR PHASE 2 OF TEST -- FM PARITY CHAIN
MPAR3A:	AR FROM PDP11		;DATA FOR "WR EVEN PAR DATA" CONO PI
	CONO PI			;SET "WR EVEN PAR DATA" BIT

	AR FROM PDP11		;FM PARITY CHAIN TEST PATTERN
	FMADR/XR, COND/FM WRITE	;DATA INTO FM
	TIME/2T, BR/AR, AR/ADX	;PDP11 WILL STOP HERE TO CHECK STATE OF KL10
.IFNOT/MODEL.B
	TIME/2T,DISP/PG FAIL,J/000,ADB/FM  ;ENABLE FM PARITY TO BE SELECTED
.IF/MODEL.B
	TIME/3T,DISP/PG FAIL,J/000,ADB/FM  ;ENABLE FM PARITY TO BE SELECTED
.ENDIF/MODEL.B
.TOC	"CRA MICRO-CODE SKIP CONDITIONS (COND 40-57) AND DISPATCHES"

;THESE SEQUENCES OF MICRO-CODED TESTS FORCE THE SEVERAL COND (40-57)
;-SKIP CONDITIONS TO BE TRUE (WITH THE HELP OF DATA LOADED INTO THE
;AR FROM THE PDP11) AND THEN LOAD THE "COND" CONDITION UNDER TEST
;TO BE LOADED TO THE C.R., WHERE THE PDP11 CAN CHECK IT.
;*****************
;FOLLOWS IS 16 NULL MICRO LOCATIONS RESERVED FOR TEST
;ECRA6 TO DO MICRO-DISPATCHES & MICRO-SKIPS INTO
=0000
1000:	AR/AR,J/1000
1001:	AR/AR,J/1001
1002:	AR/AR,J/1002
1003:	AR/AR,J/1003
1004:	AR/AR,J/1004
1005:	AR/AR,J/1005
1006:	AR/AR,J/1006
1007:	AR/AR,J/1007
1010:	AR/AR,J/1010
1011:	AR/AR,J/1011
1012:	AR/AR,J/1012
1013:	AR/AR,J/1013
1014:	AR/AR,J/1014
1015:	AR/AR,J/1015
1016:	AR/AR,J/1016
1017:	AR/AR,J/1017
;;****************--END OF RESERVED MICRO-WORDS
M6.0CRA: AR FROM PDP11		;DATA TO AR
	DISP/DIAG,J/0000	;DISPATCH TO TEST START LOCATION

M6.1CRA: 
M6.2CRA: J/1000,DISP/SH0-3	;GATE SH00-SH03 TO CRA ADR LINES
M6.3CRA: J/1000,ADA/ARX,AD/A,SKIP/AR0  ;GATE AR00 TO CRA ADR LINES
M6.4CRA: AD/B,ADB/BR,SKIP/AD0,J/1000
M6.5CRA: BR/AR,AR/ADX		;BIT00 TO BR, ALL ZEROES TO AR
		AD/B,ADB/BR,
		SKIP/AR0,J/1000  ;GATE AR00 TO CRA ADR LINE.
M6.6CRA: J/1000,SKIP/AD0		;GATE AD00 TO CRA ADR LINE
M6.7CRA: BR/AR,AR/ADX
	J/1000,DISP/DIV		;GATE BR00 TO CRA ADR LINE
M6.8CRA: BR/AR,AR/ADX	;SET BR00
	BR/AR		;CLR BR00
	J/1000,DISP/DIV	;NO SKIP
M6.9CRA: BR/AR,AR/ADX
	J/1000,DISP/SIGNS	;GATE BR00 TO CRA ADR LINE
M6.10CRA: BR/AR,AR/ADX	;SET BR00
	BR/AR		;CLR BR00
	J/1000,DISP/SIGNS ;NO SKIP
M6.11CRA: BR/AR,AR/ADX
	J/1000,SKIP/BR0		;GATE BR00 TO CRA ADR LINE
M6.12CRA: BR/AR,AR/ADX	;SET BR00
	BR/AR		;CLR BR00
	J/1000,SKIP/BR0	;NO SKIP
M6.13CRA: ARX/AD,AD/A,ADA/AR,AR/ADX  ;BIT00 TO ARX
	J/1000,SKIP/ARX0,AD/B,ADB/BR  ;AND GATE ARX00 TO CRA ADR LINE
M6.14CRA: SH/AR,ARX/SH,BR/AR	;SET AR00,ARX00,BR00
	AD/0S,ARX/AD	;CLR ARX00
	J/1000,SKIP/ARX0 ;NO SKIP
M6.15CRA: ARX/AD,AD/A,ADA/AR,AR/ADX  ;BIT00 TO ARX
	J/1000,SKIP/ADX0,AD/A	;AND GATE ADX00 TO CRA ADR LINES

M6.16CRA: SH/AR,ARX/SH,BR/AR ;SET BR00,ARX00
	AD/A,ADA/AR	;SET ADX0
	AD/0S,ADA/AR,	;CLR ADX0
	    J/1000,SKIP/ADX0 ;NO SKIP
M6.17CRA: SKIP/EVEN PAR, J/1000	;"-SH AR PAR ODD" TO CRA ADR LINES

M6.18CRA: AR/AD,AD/0S	;CLR EVEN PARITY
	J/1000,SKIP/EVEN PAR ;AND NO SKIP
M6.19CRA: COND/SR_#,#/17		;LOAD CON STATE REGISTER
	DISP/SR,J/1000		;GATE "SR00-SR03" TO CRA ADR LINES

M6.20CRA: COND/SR_#,#/00	;CLR SR00-SR03
	SH/AR,J/1000,DISP/SR	;NO SKIP
M6.21CRA: SKIP/AR18,J/1000	;GATE AR BIT 18 TO CRA ADR LINES

M6.22CRA: AR/AD,AD/0S	;CLR AR BIT 18
	J/1000,SKIP/AR18 ;NO SKIP
M6.23CRA: DISP/BYTE,J/1000	;GATE AR BIT 12 TO CRA ADR LINES

M6.24CRA: AR/AD,AD/0S	;CLR AR BIT 12
	J/1000,DISP/BYTE ;NO SKIP
M6.25CRA:
M6.27CRA: AD/A,ADA/AR,ARX/AD	;DATA TO ARX
	DISP/EA MOD,J/1000	;ARX BIT13 & "SH INDEXED" TO CRA ADR LINES

.IFNOT/MODEL.B
M6.26CRA:
M6.28CRA: SH/AR,ARX/SH	;SET ARX13 & SH INDEXED
	AD/0S,ARX/ADX	;CLR ARX13 & INDEXED
	J/1000,DISP/EA MOD ;NO SKIP
.IF/MODEL.B
M6.26CRA: SH/AR,ARX/SH	;SET ARX13 & SH INDEXED
	AD/0S,ARX/ADX	;CLR ARX13 & INDEXED
	J/1000,DISP/EA MOD ;NO SKIP

M6.28CRA: SH/AR,ARX/SH,	;SET ARX13 & SH INDEXED
	    AD/A,ADA/AR,VMA/AD	;PUT SOMETHING INTO VMA SECTION 0
	COND/LONG EN	 ;"SET COND/LONG EN"
	J/1000,DISP/EA MOD ;NO SKIP
.ENDIF/MODEL.B
M6.29CRA: SKIP/AD#0,J/1000		;GATE "-AD=0" TO CRA ADR LINES

M6.30CRA: AD/A,ADA/AR,COND/LOAD IR ;LOAD IR WITH #'S
	COND/SPEC INSTR,SPEC INSTR/SXCT  ;SET "MCL EA TYPES"
	DISP/EA TYPE,J/1000    ;"EA TYPE 09" & "EA TYPE 10" TO CRA ADR LINES

M6.31CRA: COND/SPEC INSTR,SPEC INSTR/SXCT,	 ;SET MCL EA TYPES
	    ARX/SH,SH/AR
	COND/SPEC INSTR	;CLEAR MCL EA TYPES
	DISP/EA TYPE, J/1000	;NO SKIP
M6.32CRA: SPEC/FLAG CTL, FLAG CTL/SET FLAGS  ;SET "SCD FPD"
	DISP/BYTE, J/1000	;GATE "SCD FPD" TO CRA ADR LINES
M6.33CRA: SPEC/FLAG CTL,FLAG CTL/SET FLAGS ;SET SCD FPD
	SPEC/CLR FPD	;CLEAR SCD FPD
	DISP/BYTE,J/1000 ;NO SKIP
M6.34CRA: SPEC/SCM ALT,SC/AR SHIFT	;LOAD DATA TO SC
	SKIP/SC0,J/1000		;GATE SC SIGN BIT TO CRA ADR LINES

M6.35CRA: SPEC/SCM ALT,SC/AR SHIFT,AD/0S,AR/AD,ARX/MQ ;SET SC SIGN
	SPEC/SCM ALT,AR/ADX,ADA/AR,BRX/ARX ;CLEAR SC SIGN
	SKIP/SC0,J/1000	;NO SKIP
M6.36CRA: SPEC/SCM ALT,SC/AR SHIFT,AD/0S,AR/AD  ;DATA TO SC & CLEAR AR
	FE/SCAD,SCAD/A+B,SCADA/AR0-5,SCADB/SC, ;DATA TO FE
		SPEC/SCM ALT,SC/AR SHIFT  ;AND CLEAR THE SC
	DISP/MUL,J/1000,SCADA/AR0-5,SCADB/AR0-8 ;FE SIGN BIT TO CRA ADR LINE
M6.37CRA: DISP/MUL,J/1000	;NO SKIP ON FE SIGN
M6.38CRA: SPEC/SCM ALT,SC/AR SHIFT,AD/0S,AR/AD  ;DATA TO SC & CLEAR AR
	FE/SCAD,SCAD/A+B,SCADA/AR0-5,SCADB/SC,  ;DATA TO FE
		SPEC/SCM ALT,SC/AR SHIFT,BR/AR  ;AND CLEAR SC & BR
	DISP/DIV,J/1000,SCADA/AR0-5,	;FE SIGN BIT TO CRA ADR LINES
		SCADB/AR0-8

M6.39CRA: DISP/DIV,J/1000	;NO SKIP ON FE SIGN
M6.40CRA: SPEC/SCM ALT,SC/AR SHIFT,AR/AD,  ;DATA TO SC
		AD/0S		;AND ZEROES TO AR
	SCADB/SC,SCADA/AR0-5,SCAD/A+B,  ;SET SCAD SIGN EQUAL TO 1
		SKIP/SCAD0,J/1000	;AND GATE IT TO CRA ADR LINES

M6.41CRA: SPEC/SCM ALT,SC/AR SHIFT,AR/AD,AD/0S ;DATA TO SC
	SCADB/SC,SCADA/AR0-5,SCAD/A+B ;SET SCAD SIGN
	SCAD/A,SCADA EN/0S,	;CLEAR SCAD SIGN
	    SKIP/SCAD0,J/1000	;AND NO SKIP
M6.42CRA: SPEC/SCM ALT,SC/AR SHIFT,AR/AD,  ;DATA TO SC
		AD/0S		;AND ZEROES TO AR
	SCADB/SC,SCADA/AR0-5,SCAD/A+B,  ;SET SCAD SIGN EQUAL TO 1
		DISP/BYTE,J/1000  ;AND GATE IT TO CRA ADR LINES
M6.43CRA: SPEC/SCM ALT,SC/AR SHIFT,AR/AD,AD/0S ;DTAT TO SC
	SCADB/SC,SCADA/AR0-5,SCAD/A+B	;SET SCAD SIGN
	SCAD/A,SCADA EN/0S,	;CLEAR SCAD SIGN
	    DISP/BYTE,J/1000	;AND NO SKIP
.IFNOT/MODEL.B
M6.44CRA: SPEC/SCM ALT,SC/AR SHIFT,AR/AD,  ;DATA TO SC
		AD/0S		;AND ZEROES TO AR
	SCAD/A,SCADA EN/0S,J/1000,  ;GATE "-SC.GE.36"
		SKIP/SC .LT. 36	;TO THE CRA ADR LINES

M6.45CRA: SPEC/SCM ALT,SC/AR SHIFT,ARX/MQ ;SET SC TO VALUE .GE. 36
	SKIP/SC .LT. 36,J/1000	;AND NO SKIP

.IF/MODEL.B
M6.44CRA:	AD/A,ADA/AR,VMA/AD	;ONES TO VMA SECTION
	AD/0S,VMA/AD,SPEC/LOAD PC ;ONES TO PC SECTION
	SPEC/LOAD PC		;AND NOW ZEROES TO PC SECTION
	SKIP/PC SEC0,J/1000	;AND SKIP ON "PC SECTION 0"

M6.45CRA:	AD/0S,VMA/AD	;ZEROES TO VMA SECTION
	AD/A,ADA/AR,VMA/AD,SPEC/LOAD PC ;ZEROES TO PC SECTION
	SPEC/LOAD PC	;NOW ONES TO PC SECTION
	SKIP/PC SEC0,J/1000	;AND NO SKIP SINCE "PC SCTION0" FALSE

.ENDIF/MODEL.B
M6.46CRA: SPEC/SCM ALT,SC/AR SHIFT,AR/AD,  ;DATA TO SC
		AD/0S		;AND ZEROES TO AR
	SCAD/A+B,SCADA/AR0-5,SCADB/SC,  ;SET "-SCAD = 0" TRUE
		SKIP/SCAD#0,J/1000  ;AND GATE TO CRA ADR LINES
M6.47CRA: SPEC/SCM ALT,SC/AR SHIFT,AR/AD,AD/0S ;DATA TO SC
	SCAD/A+B,SCADA/AR0-5,SCADB/SC	;SET "-SCAD=0"
	SCAD/A,SCADA EN/0S,	;SET "SCAD=0"
	    SKIP/SCAD#0,J/1000	;AND NO SKIP
M6.48CRA: AR/AD,AD/1S,ARX/ADX	;FILL AR & ARX ALL ONES
	ADA/AR,AD/A+1,	;NOW CAUSE "AD CRY-02"
		DISP/DIV,J/1000	;AND GATE IT TO CRA ADR LINES

M6.49CRA: AR/AD,AD/1S,ARX/ADX	;FILL AR & ADX ALL ONES
	ADA/AR,AD/A+1	;SET "AD CRY -02"
	AD/0S,DISP/DIV,J/1000 ;CLEAR "AD CRY -02" AND NO SKIP
M6.50CRA: AR/AD,AD/1S		;FILL AR ALL ONES
	ADA/AR,AD/A+1,		;NOW CAUSE "AD CRY-02"
		SKIP/AD CRY0,J/1000  ;AND GATE IT TO CRA ADR LINES

M6.51CRA: AR/AD,AD/1S,ARX/ADX	;FILL AR & ADX ALL ONES
	ADA/AR,AD/A+1	;SET "AD CRY -02"
	AD/0S,SKIP/AD CRY0,J/1000	;CLEAR "AD CRY -02" & NO SKIP
M6.52CRA: AD/0S,COND/LOAD IR	;CLEAR IR REG
	SKIP/AC#0,J/1000	;GATE "IR AC=0" TO THE CRA ADR LINES

M6.53CRA: COND/LOAD IR	;MAKE "IR AC=0" FALSE
	SKIP/AC#0,J/1000	;SKIP

M6.54CRA: AD/B,ADA/ARX	;AD CANT SEE AR
	AD/A,ADA/AR,DISP/NORM,J/1000 ;DISP ON IR NORM LOGIC

M6.55CRA: AD/1S,AR/AD,ARX/AD	;FILL DATA PATHS WITH ONES
	BR/AR	;BR TOO
	AD/0S,DISP/NORM,J/1000	;NO NORM DISPATCH

M6.56CRA: ARX/AD,AD/A,ADA/AR,AR/ADX ;NO SIGN BITS YET
	AR/ADX,AD/A,ADA EN/EN,BR/AR	;SIGNS TO AR,0'S TO BR
	AD/A,ADA/AR,DISP/SIGNS,J/1000 ;DISP ON AR & AD SIGNS

.IFNOT/MODEL.B
M6.57CRA: BR/AR,AD/0S,AR/AD		;SET BR SIGN
	DISP/SIGNS,J/1000	;NO DISP ON SIGNS

.IF/MODEL.B
M6.57CRA: BR/AR,AD/A,ADA/AR,AR/AD,ARX/AD	;SET BR SIGN
	AD/0S,AR/AD,ARX/AD	;CLR AD,AR,ADX SIGNS
	DISP/SIGNS,J/1000	;NO DISP ON SIGNS

.ENDIF/MODEL.B
M6.58CRA: SPEC/FLAG CTL,FLAG CTL/SET FLAGS ;SET "TRAP REQ 2"
	COND/DIAG FUNC,DIAG FUNC/CONO PAG,
	    AD/A,ADA/AR		;SET "CON TRAP EN"(NICOND 10)
	COND/SPEC INSTR,SPEC INSTR/JUST SET PI CYCLE,AR/AD*2 ;SET PI CYCLE
	AD/0S,VMA/AD,MEM/AD FUNC,BR/AR ;VMA GETS ZEROES
	SPEC/SP MEM CYCLE,MEM/AD FUNC,AD/B,ADB/BR ;"MCL VMA EXTENDED"
	MEM/WRITE,SPEC/FLAG CTL,FLAG CTL/DISMISS	;DROP PI CYCLE
	TIME/2T
	DISP/NICOND,J/1000	;DISPATCH ON NICOND
M6.59CRA: SPEC/FLAG CTL,FLAG CTL/SET FLAGS ;SET "TRAP REQ 2"
	COND/DIAG FUNC,DIAG FUNC/CONO PAG,
	    AD/A,ADA/AR		;SET "CON TRAP EN"(NICOND 10)
	COND/SPEC INSTR,SPEC INSTR/JUST SET PI CYCLE,AR/AD*2 ;SET PI CYCLE
	AD/0S,VMA/AD,MEM/AD FUNC,BR/AR ;VMA GETS ZEROES
	SPEC/SP MEM CYCLE,MEM/AD FUNC,AD/B,ADB/BR ;"MCL VMA EXTENDED"
	MEM/WRITE,SPEC/FLAG CTL,FLAG CTL/DISMISS	;DROP PI CYCLE
	TIME/2T
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE
	TIME/2T			;LET NICOND FLOPS LOAD
	DISP/NICOND,J/1000	;NO DISPATCH

M6.60CRA: AD/A,ADA/AR,MEM/AD FUNC ;SET "MCL VMA FETCH"
	SKIP/FETCH,J/1000	;SKIP ON FETCH

M6.61CRA: COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE
	SPEC/FLAG CTL,FLAG CTL/SET FLAGS	;SET "USER" & "PUBLIC"
	SKIP/FETCH,J/1000	;NO SKIP
M6.62CRA: SPEC/FLAG CTL,FLAG CTL/SET FLAGS ;SET "USER" & "PUBLIC"
	SPEC/FLAG CTL	;LEAVE "USER" & "PUBLIC"
	SKIP/KERNEL,J/1000	;SKIP

M6.63CRA: COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE
	SPEC/FLAG CTL,FLAG CTL/SET FLAGS ;SET "USER","PUBLIC"-"KERNEL" DROPS
	SKIP/KERNEL,J/1000	;NO SKIP

M6.64CRA: AR/AD,AD/B,ADB/AR*4 ;BIT7 TO 5, BIT5 TO 3
	SPEC/FLAG CTL,FLAG CTL/SET FLAGS	;SET "USER"
	SKIP/USER,J/1000	;SKIP

M6.65CRA: COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE
	AR/AD*.25,AD/A,ADA/AR	;BIT 5 TO 7, BIT7 TO 9
	SPEC/FLAG CTL,FLAG CTL/SET FLAGS ;SET "PUBLIC"
	SKIP/USER,J/1000	;NO SKIP

M6.66CRA: AR/AD*.25,AD/A,ADA/AR	;BIT5 TO 7, BIT7 TO 9
	SPEC/FLAG CTL,FLAG CTL/SET FLAGS	;SET "PUBLIC"
	SKIP/PUBLIC,J/1000	;SKIP

M6.67CRA: COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE
	AR/AD,AD/B,ADB/AR*4	;BIT 7 TO 5, BIT 5 TO 3
	SPEC/FLAG CTL,FLAG CTL/SET FLAGS	;SET "USER"
	SKIP/PUBLIC,J/1000	;NO SKIP

M6.68CRA: COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE
	SKIP/PI CYCLE,J/1000	;SKIP ON PI CYCLE

M6.69CRA: SPEC/FLAG CTL,FLAG CTL/SET FLAGS ;SET "USER" & "PUBLIC"
	SKIP/PI CYCLE,J/1000	;NO SKIP
M6.70CRA: SPEC/FLAG CTL,FLAG CTL/SET FLAGS ;SET "USER" & "PUBLIC"
	COND/EBUS CTL,EBUS CTL/REQ EBUS ;SET "APR EBUS REQ"
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE ;WAIT FOR "CON EBUS GRANT"
	SKIP/-EBUS GRANT,J/1000	;NO SKIP

M6.71CRA: SKIP/-EBUS GRANT,J/1000	;SKIP

M6.72CRA: COND/SPEC INSTR,
	    SPEC INSTR/KERNEL CYCLE	;SET "I/O LEGAL"
	SKIP/IO LEGAL,J/1000	;SKIP

M6.73CRA: AR/AD,AD/B,ADB/AR*4 ;BIT7 TO 5,BIT5 TO 3
	SPEC/FLAG CTL,FLAG CTL/SET FLAGS ;SET "USER"
	COND/SPEC INSTR,
	    SPEC INSTR/PXCT	;SET "PXCT"
	SKIP/IO LEGAL,J/1000	;NO SKIP

M6.74CRA: COND/SPEC INSTR,
	    SPEC INSTR/PXCT	;SET "PXCT"
	SKIP/P!S XCT,J/1000	;SKIP

M6.75CRA: COND/SPEC INSTR,SPEC INSTR/KERNEL CYCLE	;SET "IO LEGAL"
	SKIP/P!S XCT,J/1000	;NO SKIP

M6.76CRA: AR/AD*2,AD/A,ADA/AR
	AD/0S,VMA/AD,MEM/AD FUNC	;ZEROES TO VMA
	SPEC/SP MEM CYCLE,MEM/AD FUNC,
	    AD/A,ADA/AR	;SET "MCL VMA EXTENDED"
	MEM/WRITE
	SKIP/AC REF,J/1000	;SKIP

M6.77CRA: COND/SPEC INSTR,SPEC INSTR/PXCT-KERNEL ;SET "PXCT" & "KERNEL"
	SKIP/AC REF,J/1000	;NO SKIP

.IFNOT/MODEL.B

M6.78CRA: J/1000		;NO OP FOR MODEL A

M6.79CRA: J/1000		;NO OP FOR MODEL A

.IF/MODEL.B

M6.78CRA: VMA/AD,AD/A		;LOAD THE VMA WITH DATA FOR THIS TEST
	J/1000,SKIP/-LOCAL AC ADDR ;NO LOCAL ADDR, NO AC AT ALL..SHOULD SKIP

M6.79CRA: MEM/A RD,#/400,BR/AR	;SET "MCL SR00" TO PREVENT "VMA EXT EN"
	VMA/AD,AD/B,ADB/BR	;LOAD THE TEST PATTERN INTO THE VMA
	COND/VMA INC,MEM/EA CALC,#/42 ;NOW SET "VMA EXTENDED" TRUE
	J/1000,SKIP/-LOCAL AC ADDR ;"LOCAL AC ADDR" SHOULD BE TRUE.NO SKIP

.ENDIF/MODEL.B

M6.80CRA: AD/0S,COND/LOAD IR,SH/AR,ARX/SH	;ADDRESS NULL DRAM LOC
	ARX/ADX*.25,AD/A,ADA/AR		;SHIFT AR DATA TO
	AR/AD*2,AD/A,ADA/ARX	;CORRECT DRAM POSITION
	AD/A,ADA/AR,COND/LOAD IR ;SET DESRIED DRAM ADDRESS
	DISP/DRAM B,J/1000	;SKIP ON DRAM B

M6.81CRA: SH/AR,ARX/SH		;DATA TO ARX
	ARX/ADX*.25,AD/A,ADA/AR	;SHIFT AR DATA
	AR/AD*2,AD/A,ADA/ARX	;TO CORRECT DRAM POSITION
	AD/A,ADA/AR,COND/LOAD IR ;SET DRAM ADDRESS
	AD/0S,COND/LOAD IR	;TO NEW ADDRESS
	AD/1S,DISP/DRAM B,J/1000	;NO SKIP
M6.82CRA: AD/0S,COND/LOAD IR,SH/AR,ARX/SH	;PHONY DRAM ADDRESS
	ARX/ADX*.25,AD/A,ADA/AR	;SHIFT AR DATA
	AR/AD*2,AD/A,ADA/ARX	;TO CORRECT DRAM ADDRESS
	AD/A,ADA/AR,COND/LOAD IR ;SET CORRECT DRAM ADDRESS
	DISP/DRAM J,J/1000	;SKIP

M6.83CRA: SH/AR,ARX/SH		;DATA TO ARX
	ARX/ADX*.25,AD/A,ADA/AR	;SHIFT AR DATA
	AR/AD*2,AD/A,ADA/ARX	;TO CORRECT DRAM ADDRESS
	AD/A,ADA/AR,COND/LOAD IR ;SET DRAM ADDRESS
	AD/0S,COND/LOAD IR,ARX/MQ ;DROP DRAM ADDRESS,1S TO ARX
	SH/ARX,DISP/DRAM J,J/1000 ;NO SKIP

M6.84CRA: AD/0S,COND/LOAD IR,SH/AR,ARX/SH	;PHONY DRAM ADDRESS
	ARX/ADX*.25,AD/A,ADA/AR	;SHIFT AR DATA
	AR/AD*2,AD/A,ADA/ARX	;TO CORRECT DRAM ADDRESS
	AD/A,ADA/AR,COND/LOAD IR ;SET DRAM ADDRESS
	DISP/DRAM A RD,J/1000	;SKIP

M6.85CRA: SH/AR,ARX/SH		;DATA TO ARX
	ARX/ADX*.25,AD/A,ADA/AR	;SHIFT AR DATA
	AR/AD*2,AD/A,ADA/ARX	;TO CORRECT DRAM ADDRESS
	AD/A,ADA/AR,COND/LOAD IR ;SET DRAM ADDRESS
	AD/0S,COND/LOAD IR,ARX/MQ ;DROP DRAM ADDRESS,1S TO ARX
	SH/ARX,DISP/DRAM A RD,J/1000 ;NO SKIP

M6.86CRA: AR/AD,AD/1S,MQ/SH	;SET ALL ONES IN AR
	SPEC/SCM ALT,SC/AR SHIFT,AD/0S,  ;DATA TO SC AND
		AR/AD		;CLEAR THE AR
	FE/SCAD,SCAD/A+B,SCADA/AR0-5,SCADB/SC  ;DATA TO FE
	DISP/MUL,J/1000		;CHECK "MUL DONE" TO CRA ADR LINES
M6.87CRA: DISP/MUL,J/1000		;CHECK "MUL DONE" TRUE
M6.88CRA: DISP/BYTE,J/1000		;CHECK "MUL DONE" FALSE
M6.89CRA: DISP/SIGNS,J/1000	;CHECK "MUL DONE" FALSE
M6.90CRA: DISP/DIV,J/1000		;CHECK "MUL DONE" FALSE
M6.91CRA: J/1000	;DISP IS EQUAL TO 10	;CHECK "MUL DONE" FALSE

M6.92CRA: SKIP/-START,J/1000	;SKIP

M6.93CRA: SKIP/RUN,J/1000	;NO SKIP

M6.94CRA: TIME/2T		;WAITING FOR START TO SET
	TIME/2T
	SKIP/-START,J/1000	;NO SKIP

M6.95CRA: TIME/2T		;WAITING FOR RUN TO SET
	TIME/2T
	SKIP/RUN,J/1000		;SKIP
;SPECIAL MICRO-CODE USED ONLY IN THE LAST DTE/PI INTERFACE TEST
;THIS MICRO CODE IS USED  BY LETTING THE EBOX FREE RUN. WHEN THE  PDP11
;WANTS TO EXECUTE AN INSTRUCTION, IT SETS RUN AND CONTINUE JUST LIKE
;MONITOR START-UP CONDITIONS, AND EXECUTES THE DESIRED INSTRUCTION,
;FINISHING BY SETTING HALTED AND DROPPING BACK TO THE HALT LOOP STATE


;SPECIAL  MICRO-CODE  USED BY ALL OF THE SPECIAL  INSRUCTIONS FOR
;DROPPING BACK TO THE HALT LOOP
HALT.L:	SPEC/FLAG CTL,FLAG CTL/HALT ;CLR RUN,STOP EBOX
	COND/SPEC INSTR,SPEC INSTR/HALTED ;SET HALT LOOP FLOP
	J/STARTM		;AND BACK TO HALT LOOP



;SPECIAL HALT LOOP MICRO-CODE
=0
STARTM:	AR FROM PDP11,J/STARTM,SKIP/RUN ;WAIT FOR RUN TO SET

;WHEN IT DOES, DISPATCH OF DIAG ADDRESS REGISTER
	DISP/DIAG,J/000, 	;TO THE BEGINNING OF THE DESIRED INSTR
	    COND/SPEC INSTR	;CLR HALTED,ENABLE INTERRUPTS & PI SYS




;SPECIAL MICRO-CODE FOR EXECUTING "CONOPI"
CONO.PI:	CONO PI,J/HALT.L
;SPECIAL MICRO-CODE TO EXECUTE CONO'S OR CONI'S
DTE.IO:	AD/A,ADA/AR,COND/LOAD IR ;INSTRUCTION TO IR REGISTER
	    AR/AR,COND/ARL IND,ARL/SH,SH/AR SWAP ;DUPLICATE LEFT HALF AR

	COND/EBUS CTL,EBUS CTL/REQ EBUS ;GET EBUS FROM THE PI SYSTEM

GRANTL:	SKIP/-EBUS GRANT,J/GRANTW ;WAIT FOR PI TO GRANT EBOX THE BUS

=0
;WHEN IT DOES, SET UP CS LINES, FCN & DATA
GRANTW:	J/SETCSFCN, GEN AR,COND/EBUS CTL,EBUS CTL/IO INIT

	J/GRANTL	;WAIT FOR PI TO GRANT THAT EBUS

SETCSFCN: GEN AR,TIME/5T,EBUS CTL/IO INIT ;HOLD DATA ON THE EBUS & F02
	  GEN AR,TIME/5T,
	    COND/EBUS CTL,EBUS CTL/EBUS DEMAND, ;SET DEMAND
		J/WXFER	;AND WAIT FOR XFER

=0
EBUSW:	AR/EBUS,TIME/5T,GEN AR,COND/EBUS CTL,
		EBUS CTL/EBUS NODEMAND, ;GOT XFER..DROP DEMAND..STROBE DATA
		  J/RELEBUS		;AND RELEASE EBUS

WXFER:	GEN AR, SKIP/-EBUS XFER,J/EBUSW ;STILL AWAITING XFER

RELEBUS: GEN AR,TIME/5T,COND/EBUS CTL,EBUS CTL/REL EBUS,
	  J/HALT.L	;DROP CS,DATA & FCN AND EBUS GONE


;SPECIAL MICRO-CODE IDLE LOOP, FOR WAITING FOR AN INTERRUPT
;THE INTERRUPT API FUNCTION IS CAPTURED IN THE AR
INTLP:	COND/EBUS CTL,EBUS CTL/0	;ENSURE NO EBUS REQ

=0
INTWAIT: AR FROM PDP11,J/INTWAIT,SKIP/INTRPT ;LOOP HERE AWAITING INTERRUPT

;WHEN FALL OUT OF WAIT STATE, THE PI BOARD HAS ALREADY
;HANDLED MOST OF THE INTERRUPT..EBOX IS IN PI READY STATE,
;AND THE API FUNCTION WORD IS SITTING ON THE EBUS
	AR/EBUS,TIME/5T	;TAKE API FUNCTION INTO THE AR
	COND/SPEC INSTR,SPEC INSTR/SET PI CYCLE ;GRAP PI BOARD
	TIME/5T,SPEC/FLAG CTL,FLAG CTL/DISMISS, ;LET PI CYCLE DOWN
	  J/HALT.L		;AND RELEASE ITS GRIP ON THE DTE20
      